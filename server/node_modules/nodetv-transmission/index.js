'use strict';

var extend	= require('xtend'),
	log4js	= require('log4js'),
	uuid	= require('node-uuid');

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-transmission');


/************************************************************/

var transmission = require('transmission');

transmission.prototype.blocklist = function(callback){
	var options = {
		'arguments': {},
		'method': 'blocklist-update',
		'tag': uuid().v4()
	}
	this.callServer(options, callback);
};

transmission.prototype.getComplete = function(callback){
	this.get(function(error,transfers){
		if (error) logger.error(error);
		if (transfers && transfers.torrents){
			var list = [];
			transfers.torrents.forEach(function(torrent){
				if (torrent.percentDone != 1) return;
				var object = {
					'id': parseInt(torrent.id,10),
					'dir': torrent.downloadDir,
					'title': torrent.name,
					'files': torrent.files,
					'hash': torrent.hashString.toUpperCase(),
					'bytes': parseInt(torrent.totalSize,10)
				};
				list.push(object);
			});
			if (typeof(callback) == 'function') callback(error,list);
		}
	});
};

transmission.prototype.info = function(id,callback){
	try {
		this.get([id],callback);
	} catch(e){
		logger.error(e.message);
	}
	
};

transmission.prototype.repacked = function(hash,callback){
	this.get(function(error,transfers){
		transfers.torrents.forEach(function(transfer){
			if (transfer.hashString.toUpperCase() == hash.toUpperCase()){
				this.remove(transfer.id, true);
			}
		});
	});
};

transmission.prototype.setStatus = function(id,status,callback){
	var id = parseInt(id,10);
	if (status){
		this.start(id,callback);
	} else {
		this.stop(id,callback);
	}
};

var Transmission = function(settings){
	var defaults = {
		'host': '127.0.0.1',
		'port': '9091',
		'username': '',
		'password': '',
		'url': '/transmission/rpc'
	};
	var config = extend(defaults,settings);
	return new transmission(config);
};

module.exports = exports = Transmission;