var extend	= require('xtend'),
	fs		= require('fs'),
	http	= require('http'),
	log4js	= require('log4js'),
	mkdir	= require('mkdirp'),
	ObjectID = require('mongodb').ObjectID,
	parser	= new(require('xml2js')).Parser(),
	path	= require('path'),
	Q		= require('q'),
	request	= require('request'),
	trakt	= new (require('nodetv-traktv2'))(nconf.get('trakt')),
	util	= require('util');

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-showdata');

var episodeCollection = db.collection('episode'),
	showCollection = db.collection('show'),
	unmatchedCollection = db.collection('unmatched'),
	userCollection = db.collection('user');
var torrent	= require('nodetv-transmission')(nconf.get('transmission'));


var ShowData = {
	add: function(user,imdb){
		var self = this, deferred = Q.defer();
		var process = function(json){
			try {
				var record = {
					'status': (json.status == 'ended') ? false : true,
					'name': json.title,
					'year': parseInt(json.year,10),
					'url': json.ids.slug,
					'synopsis': json.overview,
					'runtime': parseInt(json.runtime,10),
					'imdb': json.ids.imdb,
					'tvdb': parseInt(json.ids.tvdb,10),
					'trakt': parseInt(json.ids.trakt,10),
					'genres': json.genres,
					'added': new Date(),
					'updated': new Date(json.updated_at),
					'ended': (json.status == 'ended') ? true : false
				};
				showCollection.update({'imdb':record.imdb},{$set:record},{'upsert':true}, function(error,affected,status){
					if (error){
						logger.error(error);
						deferred.reject(error);
					}
					if (affected){
						showCollection.findOne({'imdb':record.imdb}, function(error,show){
							if (error){
								logger.error(error);
								deferred.reject(error);
							}
							if (show){
								show.directory = (show.directory) ? show.directory : helper.formatDirectory(show.name);
								var dir = nconf.get('media:base') + nconf.get('media:shows:directory') + '/' + show.directory;
								if (!fs.existsSync(dir)) mkdir.sync(dir, 0775);
								if (typeof(show.hd) == 'undefined') show.hd = nconf.get('media:shows:hd') || false;
								
								showCollection.save(show, function(error,result){
									if (error){
										logger.error(error);
										deferred.reject(error);
									}	
									if (result){
										self.getArtwork(show.imdb);
										selg.getSummary(show.imdb);
										
										self.addUser(user, show.imdb).then(function(){
											return self.getListings(show.imdb);
										}).then(function(){
											self.getProgress(user,show.imdb);
											return self.getFeed(show.imdb);
										}).then(function(){
											self.getHashes(show.imdb);
										})
										deferred.resolve(show);
										
									//	trakt.auth(user.trakt).show(show.imdb).watchlist(true);
									}
								});
							}
						});
					}
				});
			} catch(e){
				logger.error('show.add:',e.message);
			}
		};
		trakt.show(imdb).summary().then(process);
		return deferred.promise;
	},
	
	complete: function(data){
		var deferred = Q.defer(), self = this;
		try {
			var hash = data.hash.toUpperCase();
			episodeCollection.findOne({'downloading':{$exists:true},$or:[{'hash':hash},{'hashes.hash':hash}]}, function(error,episode){
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (episode){
					var exts = ['.avi','.mkv','.mp4','.wmv'], file = null, size = 0;
					var files = data.files.filter(function(file){
						if (exts.indexOf(path.extname(file.name)) == -1) return false;
						return true;
					});
					if (files.length != 1) return;
					file = files[0];
					showCollection.findOne({$or:[{'_id':ObjectID(episode.show)},{'tvdb':episode.tvdb}]}, function(error,show){
						if (error){
							logger.error(error);
							deferred.reject(error);
						}
						if (show){
							var basedir = nconf.get('media:base') + nconf.get('media:shows:directory') + '/' + show.directory + '/';
							self.getFilename(file,show).then(function(filename){
								var record = {
									'file': filename,
									'size': files[0].bytesCompleted,
									'added': new Date()
								};
								if (!record.file) return;
								
								var meta = self.getEpisodeNumbers(file.name),
									source = data.dir+'/'+file.name, target = basedir+record.file;
								
								helper.fileCopy(source, target, function(error){
									if (error) {
										logger.error(error);
										deferred.reject(error);
										return;
									}
									var search = {
										$or: [{'show':ObjectID(show._id)},{'tvdb':show.tvdb}],
										'season':meta.season,
										'episode':{$in:meta.episodes}
									};
									episodeCollection.update(search,{$set:record,$unset:{'downloading':true}},{'multi':true,'w':0});
									showCollection.update({$or: [{'show':ObjectID(show._id)},{'tvdb':show.tvdb}]},{$set:{'updated':record.updated}},{'w':0});
									
									if (show.users){
										show.users.forEach(function(u){
											userCollection.findOne({'_id':ObjectID(u._id),'trakt':{$exists:true}},{'trakt':1},function(error,user){
												if (error) logger.error(error)
												if (user){
													meta.episodes.forEach(function(episode){
														trakt.auth(user.trakt).show(show.tvdb).season(search.season).episode(episode).collected(true);
													});
												}
											});
										});
									}
									deferred.resolve({'show':show,'trash':nconf.get('media:shows:autoclean')});
								});
							});
						}
					});
					
				}
			});
		} catch(e){
			logger.error(e.message);
		}
		return deferred.promise;
	},
	download: function(imdb,filter){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb}, function(error,show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				if (typeof(show.hd) == 'undefined') show.hd = false;
				logger.debug('Downloading:', show.name, filter);
				
				var addTorrent = function(hash,id){
					torrent.add(helper.createMagnet(hash), function(error,args){
						if (error) logger.error(error);
						if (args) episodeCollection.update({'_id':ObjectID(id)},{$set:{'downloading':true,'hash':args.hashString.toUpperCase()}},{'w':0});
					});
				};
				
				var search = {
					$or:[{'show':ObjectID(show._id)},{'tvdb':show.tvdb}],
					$or:[{'hashes.hash':{$exists:true}},{'hash':{$exists:true}}]
				};
				if (filter.season) search.season = parseInt(filter.season,10);
				if (filter.episode) search.episode = parseInt(filter.episode,10);
				episodeCollection.find(search).toArray(function(error,episodes){
					if (error) {
						logger.error(error);
						deferred.reject(error);
					}
					if (episodes){
						episodes.forEach(function(episode){
							if (episode.file) return;
							if (episode.hashes){
								// TODO: repack handling
								var hashes = episode.hashes.filter(function(hash){
									if (hash.hd == show.hd) return true;
									return false;
								});
								if (!hashes.length) return;
								hashes.forEach(function(hash){
									addTorrent(hash.hash,episode._id);
								});
							} else if (episode.hash){
								addTorrent(result.hash,episode._id);
							}
						});
						deferred.resolve(show);
					}
				});
			}
		});
		return deferred.promise;
	},
	downloadAll: function(imdb){
		return this.download(imdb, {});
	},
	get: function(user,imdb){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)},function(error,show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				var response = show,
					listings = [{'season':0,'label':'Specials','episodes':[]},{'season':1,'label':'Season 01','episodes':[]}];
				
				show.users.forEach(function(u){
					if (!user._id.equals(u._id)) return;
					response.progress = (u.progress) ? u.progress : {};
					if (u.seasons){
						u.seasons.forEach(function(season){
							if (!listings[season.season]) listings[season.season] = {'season':season.season,'label':'Season '+helper.zeroPadding(season.season),'episodes':[]};
							listings[season.season].progress = season;
						});
					}
				});
				
				episodeCollection.find({$or:[{'show':ObjectID(show._id)},{'tvdb':show.tvdb}]}).sort({'season':1,'episode':1}).toArray(function(error,episodes){
					if (error) logger.error(error);
					if (episodes){
						episodes.forEach(function(episode){
							try {
								if (!listings[episode.season]) listings[episode.season] = {'season':episode.season,'label':'Season '+helper.zeroPadding(episode.season),'episodes':[]};
								episode.watched = false;
								if (episode.users){
									episode.users.forEach(function(u){
										if (!user._id.equals(u._id)) return;
										episode.watched = u.watched || false;
									});
								}
								listings[episode.season].episodes.push(episode);
							} catch(e){
								logger.error(e.message);
							}
						});
					}
					response.episodes = listings;
					deferred.resolve(response);
				});
			}
		});
		return deferred.promise;
	},
	latest: function(user){
		var deferred = Q.defer(), self = this;
		
		var lastweek = new Date();
		lastweek.setDate(lastweek.getDate()-7);
		
		var count = 0, list = [];
		
		showCollection.find({'users._id': ObjectID(user._id)},{'progress':0,'seasons':0,'synopsis':0}).toArray(function(error, shows){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (shows){
				shows.forEach(function(show){
					episodeCollection.find({'tvdb':show.tvdb,'file':{$exists:true},'airdate':{$gt:lastweek}}).toArray(function(error, episodes){
						count++;
						if (error){
							logger.error(error);
							deferred.reject(error);
						}
						if (episodes){
							episodes.forEach(function(episode){
								episode.watched = false;
								if (episode.users){
									episode.users.forEach(function(u){
										if (!user._id.equals(u._id)) return;
										episode.watched = u.watched || false;
									});
								}
								list.push({'show':show,'episode':episode});
							});
						}
						if (count == shows.length) deferred.resolve(list)
					});
				});
			}
		});
		return deferred.promise;
	},
	list: function(user){
		var deferred = Q.defer();
		try {
			showCollection.find({'users._id': ObjectID(user._id)}).toArray(function(error,results){
				if (error) deferred.reject(error);
				if (results) {
					var shows = results.map(function(show){
						show.progress = {'percentage':0};
						show.users.forEach(function(u){
							if (!user._id.equals(u._id)) return;
							if (u.progress) show.progress = u.progress;
						});
						return show;
					});
					deferred.resolve(shows);
				}
			});
		} catch(e){
			logger.error(e.message);
		}
		return deferred.promise;
	},
	listings: function(user){
		var deferred = Q.defer(), self = this;
		showCollection.find({'imdb':{$exists:true}}).toArray(function(error,shows){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (shows){
				shows.forEach(function(show){
					self.getListings(show.imdb);
				});
				deferred.resolve();
			}
		});
		return deferred.promise;
	},
	match: function(user, matches){
		var self = this, deferred = Q.defer();
		matches.forEach(function(match){
			showCollection.update({'imdb':match.imdb},{$set:{'directory':match.directory}},{'upsert':true},function(error,affected){
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (affected){
					self.add(user,imdb);
					unmatchedCollection.remove({'type':'show','directory':match.directory},{'multi':true,'w':0});
					deferred.resolve(imdb);
				}
			});
		});
		return deferred.promise;
	},
	progress: function(user,imdb){
		
		// Redundant?
		
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)}, function(error, show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				var progress = {}
				show.users.forEach(function(u){
					if (!user._id.equals(u._id)) return;
					if (u.progress) progress = u.progress;
				});
				deferred.resolve(progress);
			}
		});
		return deferred.promise;
	},
	random: function(user){
		var deferred = Q.defer(), self = this;
		showCollection.find({'users._id': ObjectID(user._id), 'users.progress.percentage': {$lt: 100}, 'users.progress.next': {$exists: true}}).toArray(function(error, shows){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (shows.length){
				var rand = Math.round(Math.random()*shows.length), show = shows[rand];
				if (show){
					var response = {'show':show,'episode':{},'progress':{}};
					/*
					show.users.forEach(function(u){
						if (!user._id.equals(u._id)) return
						response.progress = u.progress;
					});
					if (response.progress.next){
						episodeCollection.findOne({'tvdb':show.tvdb,'season':response.progress.next.season,'episode':response.progress.next.number}, function(error, episode){
							if (error) {
								logger.error(error);
								deferred.reject(error);
							}
							if (episode) {
								response.episode = episode;
								deferred.resolve(response);
							}
						});
					}
					*/
				}
			}
		});
		return deferred.promise;
	},
	remove: function(user,imdb){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)},function(error,show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				var update = {$pull:{'users':{'_id':ObjectID(user._id)}}};
				if (show.users.length == 1) update.$set = {'status': false};
				showCollection.update({'imdb':imdb}, update, {'w':0});
				
				trakt.auth(user.trakt).show(show.tvdb).collected(false);
				trakt.auth(user.trakt).show(show.tvdb).watched(false);
				
				deferred.resolve();
			}
		});
		return deferred.promise;
	},
	scan: function(user){
		var self = this;
		this.scanShows(user, function(error,imdb){
			if (error) logger.error(error);
			if (imdb) self.scanEpisodes(imdb);
		});
	},
	scanEpisodes: function(imdb){
		var exts = ['.avi','.mkv','.mp4','.wmv'], self = this;
		
		showCollection.findOne({'imdb':imdb,'directory':{$exists:true}}, function(error,show){
			if (error) logger.error(error);
			if (show){
				logger.debug('Scanning files:', show.name);
				
				var showdir = nconf.get('media:base')+nconf.get('media:shows:directory')+'/'+show.directory;
				helper.listDirectory(showdir, function(error,result){
					if (error) logger.error(error)
					if (result){
						var file = result.path.replace(showdir+'/', ''), stat = result.stat;
						if (exts.indexOf(path.extname(file)) == -1) return;
						
						var meta = self.getEpisodeNumbers(file);
						if (meta && meta.episodes){
							self.getFilename(file,show).then(function(filename){
								var record = {
									'file': filename,
									'updated': new Date(),
									'added': new Date(stat.mtime)
								};
								if (!record.file || record.file == file) return;
								helper.fileMove(result.path, showdir+'/'+record.file, function(){
									episodeCollection.update({'tvdb':show.tvdb,'season':meta.season,'episode':{$in:meta.episodes}},{$set:record},{'w':0});
								});
								if (show.users){
									show.users.forEach(function(u){
										userCollection.findOne({'_id':ObjectID(u._id),'trakt':{$exists:true}},{'trakt':true}, function(error,user){
											if (error) logger.error(error);
											if (user){
												meta.episodes.forEach(function(episode){
													logger.debug(meta.season, episode, record.added);
													trakt.auth(user.trakt).show(show.imdb).season(meta.season).episode(episode).collected(true, record.added).then(function(success){
														logger.debug(success)
													}, function(error){
														logger.error(error);
													});
												});
											}
										});
									});
								}
							});
						}
					}
				});
			}
		});
	},
	scanMissing: function(imdb){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb},{'directory':true,'imdb':true,'tvdb':true},function(error,show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				episodeCollection.find({'tvdb':show.tvdb,'file':{$exists:true}}).toArray(function(error,episodes){
					if (error) logger.error(error);
					if (episodes){
						var basedir = nconf.get('media:base') + nconf.get('media:shows:directory')+'/'+show.directory+'/';
						episodes.forEach(function(episode){
							fs.exists(basedir+episode.file, function(exists){
								if (exists) return;
								logger.debug('File missing:', basedir+episode.file);
								episodeCollection.update({'file':episode.file},{$unset:{'file':true}},{'w':0});
							});
						});
					}
				});
			}
		});
		return deferred.promise;
	},
	scanShows: function(user, callback){
		var self = this;
		
		logger.debug('Scanning show library...');
		var base =  nconf.get('media:base') + nconf.get('media:shows:directory')
		
		var insertShow = function(imdb,dir){
			showCollection.update({'imdb':imdb},{$set:{'directory':dir}},{'upsert':true},function(error,affected){
				if (error) return logger.error(error);
				if (affected){
					self.add(user,imdb).then(function(show){
						if (typeof(callback) == 'function') callback(error, show.imdb);
					});
				}
			});
		};
		
		fs.readdir(base, function(error, dirs){
			if (error) logger.error(error);
			dirs.forEach(function(dir){
				fs.lstat(base + '/' + dir, function(error, stat){
					if (error) return;
					if (stat && stat.isDirectory()){
						showCollection.findOne({$or:[{'name':dir},{'directory':dir}],'tvdb':{$exists:true}},function(error,show){
							if (error) logger.error(error);
							if (show){
								var record = {'directory':dir,'updated':new Date()};
							//	showCollection.update({'tvdb':show.tvdb},{$set:record},{'w':0})
							//	if (typeof(callback) == 'function') callback(error, show.tvdb);
							} else {
								trakt.search('shows', dir).then(function(results){
									var unmatched = false
									if (results){
										if (results.length == 1){
											insertShow(results[0].ids.imdb,dir);
										} else {
											var filtered = results.filter(function(result){
												var include = true;
												dir.replace(/[^\w\s]/ig).split(' ').forEach(function(word){
													if (result.title.toLowerCase().indexOf(word.toLowerCase().trim()) == -1) include = false;
												});
												return include;
											});
											if (filtered.length == 1){
												insertShow(filtered[0].ids.imdb,dir);
											} else {
												unmatched = {'type':'show','directory':dir,'matches':filtered};
											}
										}
									} else {
										unmatched = {'type':'show','directory':dir};
									}
									if (unmatched) unmatchedCollection.update({'directory':dir},{$set:unmatched},{'upsert':true,'w':0});
								});
							}
						});
					}
				});
			});
		});
	},
	
	search: function(user, query){
		var deferred = Q.defer();
		trakt.search('show', query).then(function(results){
			deferred.resolve(results);
		}, function(error){
			deferred.reject(error);
		});
		return deferred.promise;
	},
	settings: function(user,data){
		var deferred = Q.defer();
		var record = {
			'feed': data.feed,
			'hd': !!data.hd,
			'status': !!data.status,
			'updated': new Date()
		};
		
	//	if (!record.feed || record.feed == '') record.status = false;
		if (data.format && data.format.indexOf('%S') >= 0 && data.format.indexOf('%E') >= 0) record.format = data.format
		
		showCollection.update({'_id':ObjectID(data.id),'users._id':ObjectID(user._id)},{$set:record},function(error,affected){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (affected) deferred.resolve();
		});
		return deferred.promise;
	},
	sync: function(user){
		var deferred = Q.defer(), self = this;
		
		logger.debug('Syncing show libraries');
		
		var updateShow = function(show){
	//		logger.debug('Updating:', show.title);
			var record = {
				'name': show.title,
				'year': parseInt(show.year, 10),
				'url': show.ids.slug,
				'synopsis': show.overview,
				'runtime': parseInt(show.runtime,10),
				'imdb': show.ids.imdb,
				'trakt': parseInt(show.ids.trakt,10),
				'tvdb': parseInt(show.ids.tvdb,10),
				'genres': show.genres,
				'updated': new Date(show.updated_at),
				'ended': (show.status == 'ended') ? true : false
			};
			showCollection.update({'imdb':record.imdb},{$set:record},{'upsert':true}, function(error,affected,status){
				if (error) logger.error(error);
				if (affected){
					self.getArtwork(record.imdb);
					
					self.addUser(user,record.imdb).then(function(){
						return self.getListings(record.imdb);
					}).then(function(){
						self.getProgress(user,record.imdb);
						self.getFeed(record.imdb).then(function(){
							self.getHashes(record.imdb);
						});
					});
				}
			});
		};
		var syncShows = function(results){
			try {
				for (var i in results){
					updateShow(results[i].show);
				}
			} catch(e){
				logger.error(e.message);
			}
		};
		trakt.auth(user.trakt).sync().shows.collection().then(syncShows);
		
		return deferred.promise;
	},
	unmatched: function(){
		var deferred = Q.defer();
		unmatchedCollection.find({'type':'show'}).toArray(function(error,results){
			if (error) deferred.reject(error);
			if (results) deferred.resolve(results);
		});
		return deferred.promise;
	},
	upcoming: function(user){
		var deferred = Q.defer(), limit = new Date();
		limit.setDate(limit.getDate()+7);
		episodeCollection.find({'file':{$exists:false},'airdate':{$gte:new Date(),$lte:limit}}).sort({'airdate':1}).toArray(function(error,episodes){
			if (error) logger.error(error);
			if (episodes){
				var calendar = [], count = 0;
				episodes.forEach(function(episode){
					showCollection.findOne({'status':true,$or:[{'_id':ObjectID(episode.show)},{'tvdb':episode.tvdb}],'users._id':ObjectID(user._id)}, function(error,show){
						count++;
						if (error) logger.error(error);
						if (show){
							var record = {
								'airdate': new Date(episode.airdate),
								'episode': episode,
								'show': show
							};
							calendar.push(record);
						}
					});
				});
				var wait = setInterval(function(){
					if (count > 0 && count != episodes.length) return;
					deferred.resolve(calendar);
					clearInterval(wait);
				}, 250);
			}
		});
		return deferred.promise;
	},
	watched: function(user,imdb,json){
		var deferred = Q.defer(), self = this;
		
		showCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)}, function(error,show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				var search = {
					$or: [{'show':ObjectID(show._id)},{'tvdb':show.tvdb}],
					'users._id': ObjectID(user._id)
				};
				if (typeof(json.season)!='undefined') search.season = json.season;
				if (typeof(json.episode)!='undefined') search.episode = json.episode;
				var update = {
					'_id': ObjectID(user._id),
					'watched': json.watched
				};
				
				episodeCollection.update(search,{$set:{'users.$':update}},function(error,affected){
					if (error){
						logger.error(error);
						deferred.reject(error);
					}
					if (affected == 0){
						delete search['users._id'];
						episodeCollection.update(search,{$push:{'users':update}},{'multi':true,'w':0});
					}
					deferred.resolve();
				});
				
				if (typeof(json.season)!='undefined'){
					if (typeof(json.episode)!='undefined'){
						trakt.auth(user.trakt).show(show.imdb).season(json.season).episode(json.episode).watched(json.watched);
					} else {
						trakt.auth(user.trakt).show(show.imdb).season(json.season).watched(json.watched);
					}
				} else {
					trakt.auth(user.trakt).show(show.imdb).watched(json.watched);
				}
			}
		});
		return deferred.promise;
	},
	
	addUser: function(user,imdb){
		var deferred = Q.defer(), self = this
		var addUser = function(record){
			showCollection.update({'imdb':imdb},record,function(error,affected){
				if (error) {
					logger.error(error);
					deferred.reject(error);
				}
				if (affected) deferred.resolve();
			});
		};
		showCollection.findOne({'imdb':imdb},function(error,show){
			logger.debug('Adding User:', show.name, user.username);
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				var record = {
					'_id': ObjectID(user._id),
					'username': user.username
				};
				if (show.users){
					var users = show.users.filter(function(u){
						if (ObjectID(user._id).equals(u._id)) return true;
						return false;
					});
					if (users.length) {
						deferred.resolve();
					} else {
						addUser({$addToSet:{'users':record}});
					}
				} else {
					addUser({$set:{'users':[record]}})
				}
			}
		});
		return deferred.promise;
	},
	countUnmatched: function(){
		var deferred = Q.defer();
		unmatchedCollection.count({'type':'show'}, function(error,count){
			if (error) logger.error(error);
			deferred.resolve(count);
		});
		return deferred.promise;
	},
	getArtwork: function(imdb){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb}, function(error, show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				logger.debug('Artwork:', show.name);
				var directory = nconf.get('media:base')+nconf.get('media:shows:directory')+'/'+show.directory;
				if (!fs.existsSync(directory)) mkdir.sync(directory);
				
				trakt.show(show.imdb).images().then(function(json){
					if (json.images.poster.thumb){
						try {
							var poster = fs.createWriteStream(directory+'/poster.jpg', {'flags':'w','mode':0644});
							poster.on('error', function(e){
								logger.error(e);
							});
							request.get({'uri':json.images.poster.thumb}).pipe(poster);
						} catch(e){
							logger.error(e.message)
						}
					}
					if (json.images.banner.full){
						try {
							var banner = fs.createWriteStream(directory+'/banner.jpg', {'flags':'w','mode':0644});
							banner.on('error', function(e){
								logger.error(e);
							});
							request.get({'uri':json.images.banner.full}).pipe(banner);
						} catch(e){
							logger.error(e.message);
						}
					}
					deferred.resolve();
				});
			}
		});
		return deferred.promise;
	},	
	getEpisodeNumbers: function(file){
		var file = file.toString();
		var regexp	= /(?:[a-z]+)?\s?(\d{1,2})(?:\:[\w\s]+)?[\/\s]?(?:E|x|[a-z]{2,})\s?([\d]{2,})(?:(?:E|-)\s?([\d]{2,})){0,}/i;
		var abdexp	= /(\d{4})\D?(\d{2})\D?(\d{2})/i;
		
		if (match = file.match(regexp)) {
			if (match[1] && match[2]) {
				var response = {
					type: 'seasons',
					season: null,
					episodes: []
				};
				var episode	= null;
				response.season = parseInt(match[1], 10);
				
				if (match[3]) {
					for (i = match[2]; i <= match[3]; i++) {
						response.episodes.push(parseInt(i, 10));
					}
				} else {
					// Single episode
					response.episodes.push(parseInt(match[2], 10));
				}
			}
			
		} else if (match = file.match(abdexp)) {
			// Air By Date (e.g. Colbert Report, Daily Show, Neighbours, etc)
			var reponse = {
				type: 'ABD',
				year: match[0],
				month: parseInt(match[1], 10),
				day: parseInt(match[2], 10)
			};
			
			// Thought: Trakt uses season:episode for ABDs, matching will be fun.... based on airdate?
		}
		return (response !== undefined) ? response : false;		
	},
	
	getFeed: function(imdb){
		var deferred = Q.defer(), self = this;
		var options = {
			url: 'http://tvshowsapp.com/showlist/showlist.xml',
			headers: {
				'User-Agent': 'TVShows 2 (http://tvshowsapp.com/)'
			}
		};
		showCollection.findOne({'imdb':imdb},function(error,show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				logger.debug('RSS Feed:', show.name);
				request.get(options, function(error,req,xml){
					if (error) {
						logger.error(error);
						deferred.reject(error);
					}
					try {
						parser.parseString(xml, function(error, json){
							if (error) {
								logger.error(error);
								deferred.reject(error);
							}
							if (json){
								json.shows.show.forEach(function(item){
									if (parseInt(item.tvdbid,10) != show.tvdb) return;
									var record = {
										'feed': self.fixFeedUrl(item.mirrors[0].mirror[0]),
									};
									showCollection.update({'tvdb':show.tvdb,'feed':{$exists:false}},{$set:record},{w:0});
									deferred.resolve();
								});
							}
						});
					} catch(e){
						logger.error(e.message);
						deferred.reject(e.message);
					}
				});
			}
		});
		return deferred.promise;
	},
	getFilename: function(file,show){
		// Generate a friendly filename
		var deferred = Q.defer(), self = this;
		
		var file = (typeof(file) == 'object' && file.name) ? file.name : file;
		
		var numbers = self.getEpisodeNumbers(file);
		var settings = {
			'format': (show.format && show.format != '') ? show.format : nconf.get('media:shows:format'),
			'filext': path.extname(file).replace(/^\./,'')
		};
		var token = {
			'S': null,
			'E': null,
			'T': [],
			'X': settings.filext,
		};
		var values = [];
		
		episodeCollection.find({'tvdb':show.tvdb,'season':numbers.season,'episode':{$in:numbers.episodes}}).sort({'season':1,'episode':1}).toArray(function(error,episodes){
			if (error) logger.error(error);
			if (episodes){
				episodes.forEach(function(episode){
					values.push({'episode':episode.episode,'title':episode.title.trim()});
				});
				if (values.length>1){
					values.sort(function(a,b){
						if (a.episode < b.episode) return -1;
						if (a.episode > b.episode) return 1;
						return 0;
					});
					token.E = [helper.zeroPadding(values[0].episode), helper.zeroPadding(values[values.length-1].episode)].join('-');
					values.forEach(function(value){
						token.T.push(value.title)
					})
					token.T = token.T.join('; ')
				} else {
					token.E = helper.zeroPadding(values[0].episode);
					token.T = values[0].title.trim();
				}
				token.S = helper.zeroPadding(numbers.season);
				token.X = settings.filext;
				
				if (settings.format.indexOf('%X') == -1) settings.format = settings.format+'%X';
				
				var filename = settings.format.replace(/%(\w)/g, function(match, key){
					return (token[key.toUpperCase()]) ? token[key.toUpperCase()] : key;
				});
				
				deferred.resolve(filename);
			}
		});
		return deferred.promise;
	},
	getHashes: function(imdb){
		var deferred = Q.defer(), self = this;
		// Get all the hashes we can find, and add them to the database
		showCollection.findOne({'imdb':imdb,'feed':{$exists:true,$ne:null}}, function(error, show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				logger.debug('Hashes:', show.name);
				show.feed = self.fixFeedUrl(show.feed, true);
				self.parseFeed(show.feed, null).then(function(hashes){
					if (hashes.length){
						hashes.forEach(function(item){
							var update = {
								'tvdb': show.tvdb,
								'season': item.season,
								'episode': {$in:item.episodes}
							};
							var record = {
								'hd': item.hd,
								'hash': item.hash,
								'quality': (item.hd) ? 'HD':'SD',
								'published': item.published,
								'repack': item.repack
							};
							episodeCollection.update(update,{$set:{'updated':new Date()},$addToSet:{'hashes':record}},function(error,affected){
								logger.debug(error,affected);
							});
						});
						deferred.resolve(show);
					}
					deferred.reject();
				}, function(error){
					deferred.reject(error);
				});
			}
		});
		return deferred.promise;
	},
	getLatest: function(){
		var self = this;
		
		showCollection.find({'status':true,'ended':false,'feed':{$exists:true,$ne:null}}).toArray(function(error, shows){
			if (error){
				logger.error(error);
			}
			if (shows){
				var limit = new Date();
				limit.setDate(limit.getDate()-7);
				
				shows.forEach(function(show){
					if (typeof(show.hd) == 'undefined') show.hd = false;
					self.parseFeed(show.feed, limit).then(function(hashes){
						if (hashes.length){
							hashes.forEach(function(item){
								var update = {
									'tvdb': show.tvdb,
									'season': item.season,
									'episode': {$in:item.episodes}
								};
								var record = {
									'hd': item.hd,
									'hash': item.hash,
									'quality': (item.hd) ? 'HD':'SD',
									'published': item.published,
									'repack': item.repack
								};
								episodeCollection.update(update,{$set:{'updated':new Date()},$addToSet:{'hashes':record}},{'w':0});
							});
							
						//	self.getListings(show.imdb).then(function(){
								// Download latest episode(s)
								episodeCollection.find({$or:[{'show':ObjectID(show._id)},{'tvdb':show.tvdb}],'downloading':{$exists:false},'hashes.published':{$gte:limit}}).toArray(function(error,episodes){
									if (error) logger.error(error);
									if (episodes){
										episodes.forEach(function(episode){
											var hashes = episode.hashes.filter(function(hash){
												if (hash.hd == show.hd) return true;
												return false;
											});
											if (!hashes.length) return;
											
											hashes.sort(function(a,b){
												if (a.published > b.published) return -1;
												if (a.published < b.published) return 1;
												return 0;
											});
											
											// TODO: what about repacks etc? we may end up with 2 of each
											
											
											hashes.forEach(function(hash){
												if (episode.hash){
													if (episode.hash == hash.hash) return;
													if (hash.repack == false) return;
												}
												torrent.add(helper.createMagnet(hash.hash), function(error,args){
													if (error) logger.error(error);
													if (args){
														var update = {
															'tvdb': episode.tvdb,
															'hashes.hash': hash.hash
														};
														episodeCollection.update(update,{$set:{'downloading':true,'hash':args.hashString.toUpperCase(),'status':false}},{'w':0})
													}
												});
											});
										});
									}
								});
						//	});
						}
					}, function(error){
						logger.debug(error);
					});
				});
			}
		});
	},
	getListings: function(imdb){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb}, function(error,show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				logger.debug('Listings:', show.name);
				
				var updateEpisode = function(episode){
					var record = {
						'show': ObjectID(show._id),
						'tvdb': parseInt(show.tvdb,10),
						'imdb': episode.ids.imdb,
						'trakt': parseInt(episode.ids.trakt,10),
						'season': parseInt(episode.season,10),
						'episode': parseInt(episode.number,10),
						'title': episode.title,
						'synopsis': episode.overview,
						'airdate': new Date(episode.first_aired),
						'updated': new Date(episode.updated_at)
					};
					episodeCollection.update({$or:[{'show':ObjectID(show._id)},{'tvdb':show.tvdb}],'season':record.season,'episode':record.episode},{$set:record},{'upsert':true,'w':0});
				};
				
				trakt.show(show.imdb).seasons().then(function(seasons){
					if (seasons){
						seasons.forEach(function(season){
							trakt.show(show.imdb).season(season.number).summary().then(function(episodes){
								for (var i in episodes){
									updateEpisode(episodes[i]);
								}
							});
						});
						deferred.resolve();
					}
				}, function(error){
					logger.error(error);
					deferred.reject(error);
				});
			}
		});
		return deferred.promise;
	},
	
	getProgress: function(user,imdb){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb}, function(error,show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				logger.debug('User Progress:', show.name, user.username);
				trakt.auth(user.trakt).show(show.imdb).progress.watched().then(function(progress){
					var record = {
						'progress': {
							'percentage': Math.round((progress.completed/progress.aired)*100),
							'aired': progress.aired,
							'completed': progress.completed,
							'left': progress.aired-progress.completed
						},
						'seasons': [{'season':0},{'season':1}]
					};
					
					if (progress.seasons){
						progress.seasons.forEach(function(season){
							record.seasons[season.number] = {
								'season': season.number,
								'aired': season.aired,
								'completed': season.completed,
								'left': season.aired-season.completed,
								'percentage': Math.round((season.completed/season.aired)*100)
							};
							
							if (season.episodes){
								season.episodes.forEach(function(episode){
									var search = {
										$or: [{'show':ObjectID(show._id)},{'tvdb':show.tvdb}],
										'season': season.number,
										'episode': episode.number,
										'users._id': ObjectID(user._id)
									};
									var update = {
										'_id': ObjectID(user._id),
										'watched': episode.completed,
									};
									episodeCollection.update(search,{$set:{'users.$':update}},function(error,affected,status){
										if (error) logger.error('Update user on episode:', error);
										if (affected == 0){
											delete search['users._id'];
											episodeCollection.update(search,{$push:{'users':update}},function(error,affected){
												if (error) logger.error('Add user to episode:', error)
											});
										}
									});
								});
							}
						});
					}
					showCollection.update({'imdb':show.imdb,'users._id':ObjectID(user._id)},{$set:{'users.$.progress':record.progress,'users.$.seasons':record.seasons}},{'w':0});
					deferred.resolve(record);
				}, function(error){
					logger.error(error);
					deferred.reject(error);
				});
			}
		});
		return deferred.promise;
	},
	
	getShowlist: function(){
		var deferred = Q.defer(), self = this;
		var options = {
			url: 'http://tvshowsapp.com/showlist/showlist.xml',
			headers: {'User-Agent': 'TVShows 2 (http://tvshowsapp.com/)'}
		};
		request.get(options, function(error, req, xml){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (xml){
				try {
					parser.parseString(xml, function(error, json){
						if (error){
							logger.error(error);
							deferred.reject(error);
						}	
						if (json){
							json.shows.show.forEach(function(show){
								var record = {
									'tvdb': parseInt(show.tvdbid[0],10),
									'feed': self.fixFeedUrl(show.mirrors[0].mirror[0])
								};
								showCollection.update({'tvdb':record.tvdb,'feed':{$exists:false}},{$set:record},{'w':0});
							});
							deferred.resolve();
						}
					});
				} catch(e){
					logger.error(e.message);
					deferred.reject(e.message);
				}
			}
		});
		return deferred.promise;
	},
	getSummary: function(imdb){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb},function(error,show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				trakt.show(show.imdb).summary().then(function(json){
					var record = {
						'ended': (json.status == 'ended') ? true : false,
						'url': json.ids.slug,
						'imdb': json.ids.imdb,
						'trakt': parseInt(json.ids.trakt,10),
						'tvdb': parseInt(json.ids.tvdb,10),
						'genres': json.genres,
						'name': json.title,
						'synopsis': json.overview,
						'updated': new Date(json.updated_at)
					};
					showCollection.update({'imdb':show.imdb},{$set:record},{'w':0});
					deferred.resolve(extend({},show,record));
				}, function(error){
					logger.error(error);
					deferred.reject(error);
				});
			}
		});
		return deferred.promise;
	},
	
	
	fixFeedUrl: function(url, full){
		var full = (typeof(full) == 'undefined') ? false: true;
		if (url && url.indexOf('tvshowsapp.com') >= 0 && full) {
			if (url.indexOf('.full.xml') == -1) url = url.replace(/\.xml$/, '.full.xml');
		}
		return url;
	},
	parseFeed: function(url,since){
		var self = this, deferred = Q.defer();
		try {
			if (!url) return;
			
			var userAgent = 'NodeTV '+global.pkg.version+' (http://greebowarrior.github.io/nessa/)';
			if (url.indexOf('tvshowsapp.com') >= 0) {
				url = self.fixFeedUrl(url);
				userAgent = 'TVShows 2 (http://tvshowsapp.com/)';
			}
			request.get({'url': url,'headers': {'User-Agent': userAgent}}, function(error, req, xml){
				if (error || req.statusCode != 200) return;
				try {
					parser.parseString(xml, function(error, json){
						if (error) {
							logger.error(error);
							deferred.reject(error);
							return;
						}
						if (!json || !json.rss.channel[0].item) return;
						
						var hashes = [];
						json.rss.channel[0].item.forEach(function(item){
							if (since && new Date(item.pubDate[0]) < since) return;
							
							var sources = [];
							if (item.enclosure) sources.push(item.enclosure[0]['$'].url);
							if (item.link) sources.push(item.link[0]);
							if (item.guid) sources.push(item.guid[0]['_']);
							
							var magnet = null;
							sources.forEach(function(source){
								if (magnet) return;
								if (source.indexOf('magnet') == 0) {
									magnet = source;
									return;
								}
							});
							var res = self.getEpisodeNumbers(item.title[0]);
							var response = {
								'season': res.season,
								'episodes': res.episodes,
								'hd': helper.isHD(item.title[0]),
								'published': new Date(item.pubDate[0]),
								'repack': helper.isRepack(item.title[0]),
								'hash': helper.getHash(magnet)
							};
							hashes.push(response);
						});
						deferred.resolve(hashes);
					});
				} catch(e){
					deferred.reject(e.message);
					logger.error('XML Parser error', url, e.message);
				}
			});
		} catch(e) {
			deferred.reject(e.message);
			logger.error('shows.parseFeed: %s', e.message);
		}
		return deferred.promise;
	},
	
	/****************************** Old (possibly unused) methods below ******************************/
	
	setEpisode: function(imdb, episode) {
		logger.warn('`shows.setEpisode` has been deprecated');
	},
	getCount: function(callback){
		logger.warn('`shows.getCount` - Deprecated');
	},
	getEpisode: function(tvdb, season, episode, callback){
		logger.warn('`shows.getEpisode` - Deprecated');
	},
	deleteEpisode: function(tvdb, season, episodes){
		logger.warn('`shows.deleteEpisode` - Deprecated');
	}
	
	
};
exports = module.exports = ShowData;