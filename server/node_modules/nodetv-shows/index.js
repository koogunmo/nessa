var extend	= require('xtend'),
	fs		= require('fs'),
	http	= require('http'),
	log4js	= require('log4js'),
	mkdir	= require('mkdirp'),
	ObjectID = require('mongodb').ObjectID,
	parser	= new(require('xml2js')).Parser(),
	path	= require('path'),
	Q		= require('q'),
	request	= require('request'),
	trakt	= new (require('nodetv-traktv2'))(nconf.get('trakt')),
	util	= require('util');

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-showdata');

var episodeCollection = db.collection('episode'),
	showCollection = db.collection('show'),
	unmatchedCollection = db.collection('unmatched'),
	userCollection = db.collection('user');
var torrent	= require('nodetv-transmission')(nconf.get('transmission'));



// Testing the new API
/*
var trakt2 = new (require('nodetv-traktv2'))(nconf.get('trakt'));
userCollection.findOne({'username':'martin'},{'trakt':1},function(error,user){
	// tt2015381
	trakt2.auth(user.trakt).show('how-i-met-your-mother').summary().then(function(success){
		logger.debug('movie:', success);
	},function(error){
		logger.error('movie:', error);
	});
});
*/

var ShowData = {
	
	/***** Rewritten methods *****/
	
	add: function(user, imdb, callback){
		var self = this, deferred = Q.defer();
		var process = function(json){
			try {
				var record = {
					'status': (json.status == 'ended') ? false : true,
					'name': json.title,
					'year': parseInt(json.year,10),
					'url': json.ids.slug,
					'synopsis': json.overview,
					'runtime': parseInt(json.runtime,10),
					'imdb': json.ids.imdb,
					'tvdb': parseInt(json.ids.tvdb,10),
					'trakt': parseInt(json.ids.trakt,10),
					'genres': json.genres,
					'added': new Date(),
					'updated': new Date(json.updated_at),
					'ended': (json.status == 'ended') ? true : false
				};
				showCollection.update({'imdb':record.imdb},{$set:record},{'upsert':true}, function(error,affected,status){
					if (error) logger.error(error);
					if (affected){
						showCollection.findOne({'imdb':record.imdb}, function(error,show){
							if (error) logger.error(error);
							if (show){
								// Directory not creating ?
								show.directory = (show.directory) ? show.directory : helper.formatDirectory(show.name);
								var dir = nconf.get('media:base') + nconf.get('media:shows:directory') + '/' + show.directory;
								if (!fs.existsSync(dir)) mkdir.sync(dir, 0775);
								if (typeof(show.hd) == 'undefined') show.hd = nconf.get('media:shows:hd') || false;
								
								showCollection.save(show, function(error,result){
									if (error) logger.error(error);
									if (result) {
										self.addUser(user, show.imdb);
										self.getArtwork(show.imdb);
										self.getFeed(show.imdb);
										deferred.resolve(show);
									}
									deferred.reject(error);
									if (typeof(callback) == 'function') callback(error, show.tvdb);
								});
							}
						});
					}
				});
			} catch(e){
				logger.error('show.add:',e.message);
			}
		};
		if (typeof(imdb) == 'array'){
			imdb.forEach(function(id){
				trakt.show(id).summary().then(process);
			});
		} else {
			trakt.show(imdb).summary().then(process);
		}
		return deferred.promise;
	},
	
	complete: function(data, callback){
		try {
			var self = this, hash = data.hash.toUpperCase();
			episodeCollection.findOne({'downloading':{$exists:true},$or:[{'hash':hash},{'hashes.hash':hash}]}, function(error,episode){
				if (error) logger.error(error);
				if (episode){
					var exts = ['.avi','.mkv','.mp4'], file = null, size = 0;
					var files = data.files.filter(function(file){
						if (exts.indexOf(path.extname(file.name)) == -1) return false;
						return true;
					});
					if (files.length != 1) return;
					file = files[0];
					showCollection.findOne({'tvdb': episode.tvdb}, function(error,show){
						if (error) logger.error(error);
						if (show){
							var basedir = nconf.get('media:base') + nconf.get('media:shows:directory') + '/' + show.directory + '/';
							self.getFilename(file,show).then(function(filename){
								var record = {
									'file': filename,
									'size': files[0].bytesCompleted,
									'added': new Date()
								};
								if (!record.file) return;
								
								var meta = self.getEpisodeNumbers(file.name),
									source = data.dir+'/'+file.name, target = basedir+record.file;
								
								helper.fileCopy(source, target, function(error){
									if (error) return logger.error(error);
									
									var search = {'tvdb':show.tvdb,'season':meta.season,'episode':{$in:meta.episodes}};
									episodeCollection.update(search,{$set:record,$unset:{'downloading':true}},{'multi':true,'w':0});
									showCollection.update({'tvdb':show.tvdb},{$set:{'updated':record.updated}},{'w':0});
									if (show.users){
										var library = [];
										meta.episodes.forEach(function(episode){
											library.push({'season':season,'episode':episode});
										});
										show.users.forEach(function(u){
											userCollection.findOne({'_id':ObjectID(u._id),'trakt':{$exists:true}},{'trakt':1},function(error,user){
												if (error) logger.error(error)
												if (user && library) trakt.auth(user.trakt).show(show.tvdb).season(season).episode(episode).collected(true);
											});
										});
									}
									if (typeof(callback) == 'function') callback(error, {show:show, trash:nconf.get('media:shows:autoclean')})
								});
							});
						}
					});
					
				}
			});
		} catch(e){
			logger.error(e.message);
		}
	},
	download: function(imdb, filter, callback){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb}, function(error,show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				var addTorrent = function(hash,id){
					torrent.add(helper.createMagnet(hash), function(error,args){
						if (error) logger.error(error);
						if (args) episodeCollection.update({'_id':ObjectID(id)},{$set:{'downloading':true,'hash':args.hashString.toUpperCase()}},{'w':0});
					});
				};
				var search = {'tvdb':show.tvdb,$or:[{'hashes.hash':{$exists:true}},{'hash':{$exists:true}}]};
				if (filter.season) search.season = parseInt(filter.season,10);
				if (filter.episode) search.episode = parseInt(filter.episode,10);
				episodeCollection.find(search).toArray(function(error,episodes){
					if (error) {
						logger.error(error);
						deferred.reject(error);
					}
					if (episodes){
						episodes.forEach(function(episode){
							if (episode.file) return;
							if (episode.hashes && episode.hashes.length){
								var hashes = episode.hashes.filter(function(hash){
									if (hash.hd == show.hd) return true;
									return false;
								})
								if (!hashes.length) return;
								hashes.forEach(function(hash){
									addTorrent(hash.hash,episode._id);
								});
							} else if (episode.hash){
								addTorrent(result.hash,episode._id);
							}
						});
						deferred.resolve(show.imdb);
					}
					if (typeof(callback) == 'function') callback(error, (episodes.length)?show.tvdb:false);
				});
			}
		});
	},
	downloadAll: function(imdb, callback){
		var self = this
		self.download(imdb, {}).then(callback);
	},
	get: function(user, imdb, callback){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)},function(error,show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				var response = show, listings = [{'season':0,'label':'Specials','episodes':[]},{'season':1,'label':'Season 01','episodes':[]}];
				show.users.forEach(function(u){
					if (!user._id.equals(u._id)) return;
					response.progress = (u.progress) ? u.progress : {};
					response.seasons = (u.seasons) ? u.seasons : [];
				});
				delete response.users;
				
				episodeCollection.find({'tvdb':show.tvdb}).sort({'season':1,'episode':1}).toArray(function(error,episodes){
					if (error) logger.error(error);
					if (episodes.length){
						episodes.forEach(function(episode){
							if (!listings[episode.season]) listings[episode.season] = {'season':episode.season,'label':'Season '+helper.zeroPadding(episode.season),'episodes':[]};
							var season = response.seasons.filter(function(season){
								if (season.season == episode.season) return true;
								return false;
							});
							if (season.length == 1) {
								episode.watched = season[0].episodes[episode.episode] || false;
							}
							listings[episode.season].episodes.push(episode);
						});
					}
					response.episodes = listings;
					deferred.resolve(response);
					
					if (typeof(callback) == 'function') callback(null, response);
				});
			}
		});
		return deferred.promise;
	},
	latest: function(user, callback){
		var deferred = Q.defer(), self = this;
		
		var lastweek = new Date()
		lastweek.setDate(lastweek.getDate()-7);
		
		var count = 0, list = [];
		
		showCollection.find({'users._id': ObjectID(user._id)},{'progress':0,'seasons':0,'synopsis':0}).toArray(function(error, shows){
			if (error) logger.error(error);
			if (shows) {
				shows.forEach(function(show){
					episodeCollection.find({'tvdb':show.tvdb,'file':{$exists:true},'airdate':{$gt:lastweek}}).toArray(function(error, episodes){
						count++;
						if (error) return logger.error(error);
						var seasons = [], progress = {};
						
						show.users.forEach(function(u){
							if (!user._id.equals(u._id)) return;
							if (u.progress) progress = u.progress;
							if (u.seasons) viewed = u.seasons;
						});
						
						if (episodes.length){
							episodes.forEach(function(episode){
								try {
									episode.show_name = show.name;
									episode.watched = false;
									if (viewed){
										viewed.forEach(function(season){
											if (season.season != episode.season) return;
											episode.watched = !!season.episodes[episode.episode];
										});
									}
								} catch(e){
									logger.error(e.message);
								}
								list.push(episode);
							});
						}
						if (count == shows.length && typeof(callback) == 'function') callback(null, list);
					});
				});
			}
		});
	},
	list: function(user, callback){
		var deferred = Q.defer();
		try {
			showCollection.find({'users._id': ObjectID(user._id)}).toArray(function(error,results){
				if (error) deferred.reject(error);
				if (results) deferred.resolve(results);
				
				if (typeof(callback) == 'function') callback(error,results);
			});
		} catch(e){
			logger.error(e.message);
		}
		return deferred.promise;
	},
	listings: function(user, callback){
		var deferred = Q.defer(), self = this;
		showCollection.find({'ended':false}).toArray(function(error,shows){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (shows){
				shows.forEach(function(show){
					self.getListings(show.imdb);
				});
				deferred.resolve();
			}
		});
		return deferred.promise;
	},
	match: function(user, matches, callback){
		var self = this, deferred = Q.defer();
		matches.forEach(function(match){
			// FORMAT: {'imdb': 123456, 'directory': 'Show Folder'};
			var tvdb = parseInt(match.tvdb,10);
			showCollection.update({'imdb':match.imdb},{$set:{'directory':match.directory}},{'upsert':true},function(error,affected){
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (affected){
					self.add(user, imdb);
					unmatchedCollection.remove({'type':'show','directory':match.directory},{'multi':true,'w':0});
					deferred.resolve(imdb);
				}
			});
		});
		return deferred.promise;
	},
	progress: function(user, imdb, callback){
		var deferred = Q.defer(), self = this;
		try {
			showCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)}, function(error, show){
				var progress = {};
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (show){
					show.users.forEach(function(u){
						if (!user._id.equals(u._id)) return;
						if (u.progress) progress = u.progress;
					});
					deferred.resolve(progress);
				}
				if (typeof(callback) == 'function') callback(error, progress);
			});
		} catch(e){
			logger.error(e.message);
		}
		return deferred.promise;
	},
	random: function(user, callback){
		var deferred = Q.defer(), self = this;
		try {
			showCollection.find({'users._id': ObjectID(user._id), 'users.progress.percentage': {$lt: 100}, 'users.progress.next': {$exists: true}}).toArray(function(error, shows){
				if (error) {
					logger.error(error);
					deferred.reject(error);
				}
				if (shows.length){
					var rand = Math.round(Math.random()*shows.length), show = shows[rand];
					if (show) {
						var response = {'show':show,'episode':{},'progress':{}};
						show.users.forEach(function(u){
							if (!user._id.equals(u._id)) return
							response.progress = u.progress;
						});
						if (response.progress.next){
							episodeCollection.findOne({'tvdb':show.tvdb,'season':response.progress.next.season,'episode':response.progress.next.number}, function(error, episode){
								if (error) {
									logger.error(error);
									deferred.reject(error);
								}
								if (episode) {
									response.episode = episode;
									deferred.resolve(response);
								}
							});
						}
					}
				}
			});
			deferred.promise.then(function(response){
				if (typeof(callback) == 'function') callback(null,response);
			});
		} catch(e){
			logger.error(e.message);
		}
	},
	remove: function(user, imdb, callback){
		var deferred = Q.defer(), self = this;
		try {
			showCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)},function(error,show){
				if (error) {
					logger.error(error);
					deferred.reject(error);
				}
				if (show){
					var update = {$pull:{'users':{'_id':ObjectID(user._id)}}};
					if (show.users.length == 1) update.$set = {'status': false};
					showCollection.update({'imdb':imdb}, update, {'w':0});
	//				trakt.auth(user.trakt).show(show.tvdb).collected(false);
					deferred.resolve();
				}
				if (typeof(callback) == 'function') callback(error,!!show);
			});
		} catch(e){
			logger.error(e.message);
		}
		return deferred.promise;
	},
	scan: function(user, callback){
		var self = this;
		self.scanShows(user, function(error,imdb){
			if (error) logger.error(error);
			if (imdb) self.scanEpisodes(imdb);
		});
	},
	scanEpisodes: function(imdb){
		var self = this;
		var exts = ['.avi','.mkv','.mp4'];
		
		showCollection.findOne({'imdb':imdb,'directory':{$exists:true}}, function(error,show){
			if (error) logger.error(error);
			if (show){
				var showdir = nconf.get('media:base')+nconf.get('media:shows:directory')+'/'+show.directory;
				helper.listDirectory(showdir, function(error,result){
					var file = result.path.replace(showdir+'/', '');
					if (exts.indexOf(path.extname(file)) == -1) return;
					var meta = self.getEpisodeNumbers(file);
					if (meta && meta.episodes){
						self.getFilename(file,show).then(function(filename){
							var record = {
								'file': filename,
								'updated': new Date()
							};
							if (!record.file || record.file == file) return;
							helper.fileMove(result.path, showdir+'/'+record.file, function(){
								episodeCollection.update({'tvdb':show.tvdb,'season':meta.season,'episode':{$in:meta.episodes}},{$set:record},{'w':0});
							});
						});
					}
				});
			}
		});
	},
	scanMissing: function(imdb){
		var deferred = Q.defer(), self = this;
		showCollection.findOne({'imdb':imdb},{'directory':true,'imdb':true,'tvdb':true},function(error,show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				episodeCollection.find({'tvdb':show.tvdb,'file':{$exists:true}}).toArray(function(error,episodes){
					if (error) logger.error(error);
					if (episodes.length){
						var basedir = nconf.get('media:base') + nconf.get('media:shows:directory')+'/'+show.directory+'/';
						episodes.forEach(function(episode){
							fs.exists(basedir+episode.file, function(exists){
								if (exists) return;
								logger.debug('File missing:', basedir+episode.file);
								episodeCollection.update({'file':episode.file},{$unset:{'file':true}},{'w':0});
							});
						});
					}
				});
			}
		});
		return deferred.promise;
	},
	scanShows: function(user, callback){
		var self = this;
		
		logger.debug('Scanning show library...');
		var base =  nconf.get('media:base') + nconf.get('media:shows:directory')
		
		var insertShow = function(imdb,dir){
			showCollection.update({'imdb':imdb},{$set:{'directory':dir}},{'upsert':true},function(error,affected){
				if (error) return logger.error(error);
				if (affected){
					self.add(user,imdb).then(function(show){
						if (typeof(callback) == 'function') callback(error, show.imdb);
					});
				}
			});
		};
		
		fs.readdir(base, function(error, dirs){
			if (error) logger.error(error);
			dirs.forEach(function(dir){
				fs.lstat(base + '/' + dir, function(error, stat){
					if (error) return;
					if (stat && stat.isDirectory()){
						showCollection.findOne({$or:[{'name':dir},{'directory':dir}],'tvdb':{$exists:true}},function(error,show){
							if (error) logger.error(error);
							if (show){
								var record = {'directory':dir,'updated':new Date()};
							//	showCollection.update({'tvdb':show.tvdb},{$set:record},{'w':0})
							//	if (typeof(callback) == 'function') callback(error, show.tvdb);
							} else {
								trakt.search('shows', dir).then(function(results){
									var unmatched = false
									if (results){
										if (results.length == 1){
											insertShow(results[0].ids.imdb,dir);
										} else {
											var filtered = results.filter(function(result){
												var include = true;
												dir.replace(/[^\w\s]/ig).split(' ').forEach(function(word){
													if (result.title.toLowerCase().indexOf(word.toLowerCase().trim()) == -1) include = false;
												});
												return include;
											});
											if (filtered.length == 1){
												insertShow(filtered[0].ids.imdb,dir);
											} else {
												unmatched = {'type':'show','directory':dir,'matches':filtered};
											}
										}
									} else {
										unmatched = {'type':'show','directory':dir};
									}
									if (unmatched) unmatchedCollection.update({'directory':dir},{$set:unmatched},{'upsert':true,'w':0});
								});
							}
						});
					}
				});
			});
		});
	},
	search: function(user, query, callback){
		var deferred = Q.defer();
		try {
			trakt.search('show', query).then(function(results){
				deferred.resolve(results);
				if (typeof(callback) == 'function') callback(null,results)
			}, function(error){
				deferred.reject(error);
			});
		} catch(e){
			logger.error(e.message);
		}
		return deferred.promise;
	},
	settings: function(user,data,callback){
		var deferred = Q.defer();
		if (!data.feed || data.feed == '') data.status = false;
		var record = {
			'feed': data.feed,
			'hd': !!data.hd,
			'status': !!data.status,
			'updated': new Date()
		};
		if (data.format && data.format.indexOf('%S') >= 0 && data.format.indexOf('%E') >= 0){
			// Season and Episode are required, for obvious reasons
			record.format = data.format
		}
		showCollection.update({'_id':ObjectID(data._id),'users._id':ObjectID(user._id)},{$set:record},function(error,affected){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (affected) deferred.resolve();
			if (typeof(callback) == 'function') callback(error, !!affected);
		});
		return deferred.promise;
	},
	summary: function(user,imdb,callback){
		// compatibility method - deprecate soon
		return this.get(user,imdb,callback);
	},
	sync: function(user, callback){
		var deferred = Q.defer(), self = this;
		try {
			logger.debug('Syncing...');
			
			trakt.auth(user.trakt).sync('shows').then(function(results){
				results.forEach(function(result){
					var show = result.show;
					var record = {
						'status': (json.status == 'ended') ? false : true,
						'name': show.title,
						'year': parseInt(show.year, 10),
						'url': show.ids.slug,
						'synopsis': show.overview,
						'runtime': parseInt(show.runtime,10),
						'imdb': show.ids.imdb,
						'trakt': parseInt(show.ids.trakt,10),
						'tvdb': parseInt(show.ids.tvdb,10),
						'genres': show.genres,
						'updated': new Date(),
						'ended': (json.status == 'ended') ? true : false
					};
					logger.debug(record);
				});
				
			}, function(error){
				logger.error(error)
			})
			
			return;
			
			trakt(user.trakt).user.library.shows.all(function(error, shows){
				logger.debug('Syncing show library...');
				if (error) logger.error(error);
				if (shows){
					logger.debug('Show library: ', shows.length);
					shows.forEach(function(show){
						var record = {
							'status': (json.status == 'Ended') ? false : true,
							'name': show.title,
							'year': parseInt(show.year, 10),
							'url': show.url.split('/').pop(),
							'synopsis': show.overview,
							'runtime': parseInt(json.runtime,10),
							'imdb': show.imdb_id,
							'tvdb': parseInt(show.tvdb_id,10),
							'genres': show.genres,
							'updated': new Date(),
							'ended': (json.status == 'Ended') ? true : false
						};
						showCollection.update({'tvdb':record.tvdb},{$set:record},{'upsert':true},function(error,affected,status){
							if (error) logger.error(error);
							if (affected){
								self.addUser(user, record.tvdb);
								self.getArtwork(record.tvdb);
								if (!show.feed) self.getFeed(record.tvdb);
							}
						});
					});
					deferred.resolve(shows.length);
				}
				deferred.reject(error);
				if (typeof(callback) == 'function') callback(error, shows.length);
			});
		} catch(e){
			logger.error('Show sync: ', e.message);
		}
		return deferred.promise;
	},
	unmatched: function(callback){
		unmatchedCollection.find({'type':'show'}).toArray(callback);
	},
	upcoming: function(user){
		var deferred = Q.defer(), limit = new Date();
		limit.setDate(limit.getDate()+7);
		episodeCollection.find({'airdate':{$gte:new Date(),$lte:limit}}).sort({'airdate':1}).toArray(function(error,episodes){
			if (error) logger.error(error);
			if (episodes){
				var calendar = [];
				episodes.forEach(function(episode){
					showCollection.findOne({'tvdb':episode.tvdb}, function(error,show){
						var record = {
							'airdate': new Date(episode.airdate),
							'episode': episode,
							'show': show
						};
						calendar.push(record);
					});
				});
				var wait = setInterval(function(){
					if (calendar.length != episodes.length) return;
					deferred.resolve(calendar);
					clearInterval(wait);
				}, 250);
			}
		});
		return deferred.promise;
	},
	watched: function(user,imdb,json,callback){
		var deferred = Q.defer(), wait = Q.defer(), self = this;
		if (json.season) {
			if (json.episode){
				trakt.auth(user.trakt).show(imdb).season(json.season).episode(json.episode).watched(json.watched).then(function(){
					wait.resolve();
				}, function(){
					wait.reject();
				});
			} else {
				trakt.auth(user.trakt).show(imdb).season(json.season).watched(json.watched).then(function(){
					wait.resolve();
				}, function(){
					wait.reject();
				});
			}
		} else {
			trakt.auth(user.trakt).show(imdb).watched(json.watched).then(function(){
				wait.resolve();
			}, function(){
				wait.reject();
			});
		}
		wait.promise.then(function(){
			self.getProgress(user,imdb);
			deferred.resolve()
			if (typeof(callback) == 'function') callback(null,true);
		});
		return deferred.promise;
	},
	
	addUser: function(user,imdb){
		var deferred = Q.defer(), self = this
		var addUser = function(record){
			showCollection.update({'imdb':imdb},record,function(error,affected){
				if (error) {
					logger.error(error);
					deferred.reject(error);
				}
				if (affected) self.getProgress(user,imdb);
			});
		};
		showCollection.findOne({'imdb':imdb},function(error,show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				var record = {
					'_id': ObjectID(user._id),
					'username': user.username
				};
				if (show.users){
					var users = show.users.filter(function(u){
						if (ObjectID(user._id).equals(u._id)) return true;
						return false;
					});
					if (!users.length) {
						addUser({$addToSet:record});
					}
				} else {
					addUser({$set:{'users':[record]}})
				}
			}
		});
		return deferred.promise;
	},
	countUnmatched: function(){
		var deferred = Q.defer();
		unmatchedCollection.count({'type':'show'}, function(error,count){
			if (error) logger.error(error);
			deferred.resolve(count);
		});
		return deferred.promise;
	},
	getArtwork: function(imdb, callback){
		var deferred = Q.defer(), self = this;
		
		showCollection.findOne({'imdb':imdb}, function(error, show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				trakt.show(show.imdb).images().then(function(json){
					if (json.images.poster){
						try {
							var poster = fs.createWriteStream(nconf.get('media:base') + nconf.get('media:shows:directory') + '/' + show.directory + '/poster.jpg', {flags: 'w', mode: 0644});
							poster.on('error', function(e){
								logger.error(e);
							});
							require('request')(json.images.poster.thumb).pipe(poster);
						} catch(e){
							logger.error(e.message)
						}
					}
					if (json.images.banner){
						try {
							var banner = fs.createWriteStream(nconf.get('media:base') + nconf.get('media:shows:directory') + '/' + show.directory + '/banner.jpg', {flags: 'w', mode: 0644});
							banner.on('error', function(e){
								logger.error(e);
							});
							require('request')(json.images.banner.full).pipe(banner);
						} catch(e){
							logger.error(e.message);
						}
					}
					deferred.resolve();
				});
			}
			if (typeof(callback) == 'function') callback(error, show.imdb);
		});
		return deferred.promise;
	},	
	getEpisodeNumbers: function(file){
		var file = file.toString();
		var regexp	= /(?:[a-z]+)?\s?(\d{1,2})(?:\:[\w\s]+)?[\/\s]?(?:E|x|[a-z]{2,})?\s?([\d]{2,})(?:(?:E|-)\s?([\d]{2,})){0,}/i;
		var abdexp	= /(\d{4})\D?(\d{2})\D?(\d{2})/ig;
		
		if (match = file.match(regexp)) {
			if (match[1] && match[2]) {
				var response = {
					type: 'seasons',
					season: null,
					episodes: []
				};
				var episode	= null;
				response.season = parseInt(match[1], 10);
				
				if (match[3]) {
					for (i = match[2]; i <= match[3]; i++) {
						response.episodes.push(parseInt(i, 10));
					}
				} else {
					// Single episode
					response.episodes.push(parseInt(match[2], 10));
				}
			}
			
		} else if (match = file.match(abdexp)) {
			// Air By Date (e.g. Colbert Report, Daily Show, Neighbours, etc)
			var reponse = {
				type: 'ABD',
				year: match[0],
				month: parseInt(match[1], 10),
				day: parseInt(match[2], 10)
			};
			
			// Thought: Trakt uses season:episode for ABDs, matching will be fun.... based on airdate?
		}
		return (response !== undefined) ? response : false;		
	},
	getEpisodes: function(tvdb,callback){
		
		// ???
		
		var deferred = Q.defer(), self = this;
		
		var seasons = [{'season':0},{'season':1}];
		episodeCollection.find({'tvdb':tvdb}).sort({'season':1,'episode':1}).toArray(function(){
			
		});
		
		return deferred.promise;
	},
	getFeed: function(imdb,callback){
		var deferred = Q.defer(), self = this;
		var options = {
			url: 'http://tvshowsapp.com/showlist/showlist.xml',
			headers: {
				'User-Agent': 'TVShows 2 (http://tvshowsapp.com/)'
			}
		};
		showCollection.findOne({'imdb':imdb},{'imdb':true,'tvdb':true},function(error,show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				request.get(options, function(error,req,xml){
					if (error) {
						logger.error(error);
						deferred.reject(error);
					}
					try {
						parser.parseString(xml, function(error, json){
							if (error) {
								logger.error(error);
								deferred.reject(error);
							}
							if (json){
								json.shows.show.forEach(function(item){
									if (parseInt(item.tvdbid,10) != show.tvdb) return;
									var record = {
										'feed': self.fixFeedUrl(item.mirrors[0].mirror[0]),
									};
									showCollection.update({'tvdb':show.tvdb,'feed':{$exists:false}},{$set:record},{w:0});
								});
								deferred.resolve();
							}
						});
					} catch(e){
						logger.error(e.message);
						deferred.reject(e.message);
					}
				});
			}
		});
		return deferred.promise;
	},
	getFilename: function(file,show){
		// Generate a friendly filename
		var deferred = Q.defer(), self = this;
		
		var file = (typeof(file) == 'object' && file.name) ? file.name : file;
		
		var numbers = self.getEpisodeNumbers(file);
		var settings = {
			'format': (show.format && show.format != '') ? show.format : nconf.get('media:shows:format'),
			'filext': path.extname(file).replace(/^\./,'')
		};
		var token = {
			'S': null,
			'E': null,
			'T': [],
			'X': settings.filext,
		};
		var values = [];
		
		episodeCollection.find({'tvdb':show.tvdb,'season':numbers.season,'episode':{$in:numbers.episodes}}).sort({'season':1,'episode':1}).toArray(function(error,episodes){
			if (error) logger.error(error);
			if (episodes){
				episodes.forEach(function(episode){
					values.push({'episode':episode.episode,'title':episode.title.trim()});
				});
				if (values.length>1){
					values.sort(function(a,b){
						if (a.episode < b.episode) return -1;
						if (a.episode > b.episode) return 1;
						return 0;
					});
					token.E = [helper.zeroPadding(values[0].episode), helper.zeroPadding(values[values.length-1].episode)].join('-');
					values.forEach(function(value){
						token.T.push(value.title)
					})
					token.T = token.T.join('; ')
				} else {
					token.E = helper.zeroPadding(values[0].episode);
					token.T = values[0].title.trim();
				}
				token.S = helper.zeroPadding(numbers.season);
				token.X = settings.filext;
				
				if (settings.format.indexOf('%X') == -1) settings.format = settings.format+'%X';
				
				var filename = settings.format.replace(/%(\w)/g, function(match, key){
					return (token[key.toUpperCase()]) ? token[key.toUpperCase()] : key;
				});
				
				deferred.resolve(filename);
			}
		});
		return deferred.promise;
	},
	getHashes: function(imdb, callback){
		var deferred = Q.defer(), self = this;
		// Get all the hashes we can find, and add them to the database
		showCollection.findOne({'imdb':imdb,'feed':{$exists:true,$ne:null}}, function(error, show){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				show.feed = self.fixFeedUrl(show.feed, true);
				self.parseFeed(show.feed, null, function(error,hashes){
					if (error) logger.error(error);
					if (hashes.length){
						hashes.forEach(function(item){
							var update = {
								'tvdb': show.tvdb,
								'season': item.season,
								'episode': {$in:item.episodes}
							};
							var record = {
								'hd': item.hd,
								'hash': item.hash,
								'quality': (item.hd) ? 'HD':'SD',
								'published': item.published,
								'repack': item.repack
							};
							episodeCollection.update(update,{$set:{'updated':new Date()},$addToSet:{'hashes':record}},{'w':0});
						});
					}
					deferred.resolve(show.imdb);
				});
				if (typeof(callback) == 'function') callback(error,imdb);
			}
		});
		return deferred.promise;
	},
	getLatest: function(){
		var self = this;
		showCollection.find({'status':true,'ended':false,'feed':{$exists:true,$ne:null}}).toArray(function(error, shows){
			if (error) logger.error(error);
			if (shows){
				var limit = new Date();
				limit.setDate(limit.getDate()-7);
				
				shows.forEach(function(show){
					if (typeof(show.hd) == 'undefined') show.hd = false;
					
					self.parseFeed(show.feed, limit, function(error, hashes){
						if (error) logger.error(error);
						if (hashes.length){
							hashes.forEach(function(item){
								var update = {
									'tvdb': show.tvdb,
									'season': item.season,
									'episode': {$in:item.episodes}
								};
								var record = {
									'hd': item.hd,
									'hash': item.hash,
									'quality': (item.hd) ? 'HD':'SD',
									'published': item.published,
									'repack': item.repack
								};
								episodeCollection.update(update,{$set:{'updated':new Date()},$addToSet:{'hashes':record}},{'w':0});
							});
							
							// Download latest episode(s)
							episodeCollection.find({'tvdb':show.tvdb,'downloading':{$exists:false},'hashes.published':{$gte:limit}}).toArray(function(error,episodes){
								if (error) logger.error(error);
								if (episodes){
									episodes.forEach(function(episode){
										var hashes = episode.hashes.filter(function(hash){
											if (hash.hd == show.hd) return true;
											return false;
										});
										if (!hashes.length) return;
										
										hashes.sort(function(a,b){
											if (a.published > b.published) return -1;
											if (a.published < b.published) return 1;
											return 0;
										});
										
										// TODO: what about repacks etc? we may end up with 2 of each
										
										
										hashes.forEach(function(hash){
											if (episode.hash){
												if (episode.hash == hash.hash) return;
												if (hash.repack == false) return;
											}
											torrent.add(helper.createMagnet(hash.hash), function(error,args){
												if (error) logger.error(error);
												if (args){
													var update = {
														'tvdb': episode.tvdb,
														'hashes.hash': hash.hash
													};
													episodeCollection.update(update,{$set:{'downloading':true,'hash':args.hashString.toUpperCase(),'status':false}},{'w':0})
												}
											});
											self.getListings(show.tvdb);
										});
									});
								}
							});
						}
					});
				});
			}
		});
	},
	getListings: function(imdb){
		// TODO: Can this be improved?
		var deferred = Q.defer(), self = this;
		
		showCollection.findOne({'imdb':imdb}, function(error,show){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (show){
				trakt.show(show.imdb).seasons().then(function(seasons){
					if (seasons){
						var count = 0;
						seasons.forEach(function(season){
							count += season.episode_count;
							
							for (var i=1;i<=season.episode_count;i++){
								trakt.show(show.imdb).season(season.number).episode(i).summary().then(function(episode){
									var record = {
										'tvdb': parseInt(show.tvdb,10),
										'season': parseInt(episode.season,10),
										'episode': parseInt(episode.number,10),
										'title': episode.title,
										'synopsis': episode.overview,
										'airdate': new Date(episode.first_aired),
										'updated': new Date(episode.updated_at)
									};
									episodeCollection.update({'tvdb':show.tvdb,'season':record.season,'episode':record.episode},{$set:record},{'upsert':true,'w':0});
								}, function(error){
									logger.error(error);
									deferred.reject(error);
								});
							}
						});
					}
				}, function(error){
					logger.error(error);
					deferred.reject(error);
				})
			}
		});
		return deferred.promise;
	},
	
	getProgress: function(user,imdb){
		var deferred = Q.defer(), self = this;
		
		trakt.auth(user.trakt).show(imdb).progress.watched().then(function(progress){
			// TODO: This is the old Trakt 1.0 format - we should probably improve on it at some point
			var record = {
				'progress': {
					'percentage': Math.round((progress.completed/progress.aired)*100),
					'aired': progress.aired,
					'completed': progress.completed,
					'left': progress.aired-progress.completed
				},
				'seasons': [{'season':0},{'season':1}]
			};
			progress.seasons.forEach(function(season){
				var obj = {
					'season': season.number,
					'percentage': Math.round((season.completed/season.aired)*100),
					'aired': season.aired,
					'completed': season.completed,
					'left': season.aired-season.completed,
					'episodes': {}
				};
				season.episodes.forEach(function(episode){
					obj.episodes[episode.number.toString()] = episode.completed;
				});
				record.seasons[season.number] = obj;	
			});
			showCollection.update({'imdb':imdb,'users._id':ObjectID(user._id)},{$set:{'users.$.progress':record.progress,'users.$.seasons':record.seasons}},{'w':0});
			deferred.resolve();
		});
		return deferred.promise;
	},
	
	getShowlist: function(){
		var deferred = Q.defer(), self = this;
		var options = {
			url: 'http://tvshowsapp.com/showlist/showlist.xml',
			headers: {'User-Agent': 'TVShows 2 (http://tvshowsapp.com/)'}
		};
		request.get(options, function(error, req, xml){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (xml){
				try {
					parser.parseString(xml, function(error, json){
						if (error){
							logger.error(error);
							deferred.reject(error);
						}	
						if (json){
							json.shows.show.forEach(function(show){
								var record = {
									'tvdb': parseInt(show.tvdbid[0],10),
									'feed': self.fixFeedUrl(show.mirrors[0].mirror[0])
								};
								showCollection.update({'tvdb':record.tvdb,'feed':{$exists:false}},{$set:record},{'w':0});
								if (typeof(callback) == 'function') callback(error, record.tvdb);
							});
						}
					});
				} catch(e){
					logger.error(e.message);
					deferred.reject(e.message);
				}
			}
		});
		return deferred.promise;
	},
	getSummary: function(imdb, callback){
		var deferred = Q.defer(), self = this;
		trakt.show(imdb).summary().then(function(json){
			showCollection.findOne({'imdb':imdb},function(error,show){
				if (error) {
					logger.error(error);
					deferred.reject(error);
				}
				if (show){
					var record = {
						'ended': (json.status == 'ended') ? true : false,
						'url': json.ids.slug,
						'imdb': json.ids.imdb,
						'trakt': parseInt(json.ids.trakt,10),
						'tvdb': parseInt(json.ids.tvdb,10),
						'genres': json.genres,
						'name': json.title,
						'synopsis': json.overview,
						'updated': new Date(json.updated_at)
					};
					showCollection.update({'imdb':show.imdb},{$set:record},{'w':0});
					deferred.resolve(show.imdb);
				}
				if (typeof(callback) == 'function') callback(error, show.imdb);
			});
		}, function(error){
			logger.error(error);
		});
		return deferred.promise;
	},
	
	fixFeedUrl: function(url, full){
		var full = (typeof(full) == 'undefined') ? false: true;
		if (url && url.indexOf('tvshowsapp.com') >= 0 && full) {
			if (url.indexOf('.full.xml') == -1) url = url.replace(/\.xml$/, '.full.xml');
		}
		return url;
	},
	parseFeed: function(url, since, callback){
		var self = this, deferred = Q.defer();
		try {
			if (!url) return;
			
			var userAgent = 'NodeTV '+global.pkg.version+' (http://greebowarrior.github.io/nessa/)';
			if (url.indexOf('tvshowsapp.com') >= 0) {
				url = self.fixFeedUrl(url);
				userAgent = 'TVShows 2 (http://tvshowsapp.com/)';
			}
			request.get({'url': url,'headers': {'User-Agent': userAgent}}, function(error, req, xml){
				if (error || req.statusCode != 200) return;
				try {
					parser.parseString(xml, function(error, json){
						if (error) {
							logger.error(error);
							deferred.reject(error);
							return;
						}
						if (!json || !json.rss.channel[0].item) return;
						
						var hashes = [];
						json.rss.channel[0].item.forEach(function(item){
							if (since && new Date(item.pubDate[0]) < since) return;
							
							var sources = [];
							if (item.enclosure) sources.push(item.enclosure[0]['$'].url);
							if (item.link) sources.push(item.link[0]);
							if (item.guid) sources.push(item.guid[0]['_']);
							
							var magnet = null;
							sources.forEach(function(source){
								if (magnet) return;
								if (source.indexOf('magnet') == 0) {
									magnet = source;
									return;
								}
							});
							var res = self.getEpisodeNumbers(item.title[0]);
							var response = {
								'season': res.season,
								'episodes': res.episodes,
								'hd': helper.isHD(item.title[0]),
								'published': new Date(item.pubDate[0]),
								'repack': helper.isRepack(item.title[0]),
								'hash': helper.getHash(magnet)
							};
							hashes.push(response);
						});
						deferred.resolve(hashes);
						if (typeof(callback) == 'function') callback(null, hashes);
					});
				} catch(e){
					deferred.reject(e.message);
					logger.error('XML Parser error', url, e.message);
				}
			});
		} catch(e) {
			deferred.reject(e.message);
			logger.error('shows.parseFeed: %s', e.message);
		}
		return deferred.promise;
	},
	
	/****************************** Old (possibly unused) methods below ******************************/
	
	setEpisode: function(imdb, episode) {
		logger.warn('`shows.setEpisode` has been deprecated');
	},
	getCount: function(callback){
		logger.warn('`shows.getCount` - Deprecated');
	},
	getEpisode: function(tvdb, season, episode, callback){
		logger.warn('`shows.getEpisode` - Deprecated');
	},
	deleteEpisode: function(tvdb, season, episodes){
		logger.warn('`shows.deleteEpisode` - Deprecated');
	}
	
	
};
exports = module.exports = ShowData;