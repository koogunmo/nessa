'use strict';

var crypto		= require('crypto'),
	log4js		= require('log4js'),
	notp		= require('notp'),
	ObjectID	= require('mongodb').ObjectID,
	Q			= require('q'),
	trakt	 	= new (require('nodetv-traktv2'))(nconf.get('trakt')),
	uuid		= require('node-uuid');

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-users');


var movieCollection = db.collection('movie'),
	showCollection = db.collection('show'),
	userCollection = db.collection('user');


var UserData = {
	add: function(){
		var deferred = Q.defer();
		// Create new user
		
		
		return deferred.promise;
	},
	
	check: function(session){
		var deferred = Q.defer();
		userCollection.findOne({'sessions.session':session},{'password':false,'sessions':false,'trakt':false}, function(error, user){
			if (error){
				logger.error(error);
				deferred.reject();
			}
			if (user) deferred.resolve(user);
			deferred.reject();
		});
		return deferred.promise;
	},
	
	clean: function(){
		
	},
	
	get: function(id){
		var deferred = Q.defer();
		userCollection.findOne({'_id':ObjectID(id)},{'password':0}, function(error, json){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			
			if (!json) json = {_id: null};
			/*
			if (!json.mfa) {
				var secret = notp.totp.gen();
				json.mfa = {
					confirmed: false,
					enabled: false,
					secret: {
						ascii: secret,
						base32: ''
					}
				}
			} else if (!json.mfa.secret){
				json.mfa.secret.ascii = notp.totp.gen()
			}
			*/
			deferred.resolve(json);
		});
		return deferred.promise;
	},
	
	list: function(){
		var deferred = Q.defer();
		userCollection.find({},{'password':false}).sort({'username':1}).toArray(function(error,users){
			if (error) deferred.reject(error);
			if (users) deferred.resolve(users);
		});
		return deferred.promise;
	},
	
	login: function(data){
		var deferred = Q.defer();
		data.hashed = crypto.createHash('sha256').update(data.password).digest('hex');
		userCollection.findOne({'username':data.username,'password':data.hashed},{'password':false,'sessions':false}, function(error,user){
			var response = {'error':false,'success':false,'session':null,'user':{}};
			if (error){
				logger.error(error);
				response.error = error;
				deferred.reject(response);
			}
			if (user){
				response.success = true;
				response.session = uuid.v4();
				if (user.trakt){
					trakt.auth(user.trakt).token().then(function(json){
						userCollection.update({'_id':ObjectID(user._id)},{$set:{'trakt.token':json.token}},{'w':0});
					});
					delete user.trakt;
				}
				response.user = user;
				
				var session = {
					'session': response.session,
					'timestamp': new Date()
				};
				userCollection.update({'_id':ObjectID(user._id)},{$addToSet:{'sessions':session}},{'w':0});
				deferred.resolve(response);
			}
			deferred.reject();
		});
		return deferred.promise;
	},
	logout: function(session, flush){
		var deferred = Q.defer();
		
		if (flush){
			var update = {$unset:{'sessions':true}};
		} else {
			var update = {$pull:{'sessions':{'session':session}}};
		}
		userCollection.update({'sessions.session':session}, update, {'w':0});
		deferred.resolve();
		
		return deferred.promise;
	},
	
	remove: function(id){
		var deferred = Q.defer(), self = this;
		userCollection.findOne({'_id':ObjectID(id)}, function(error, user){
			if (error) logger.error(error);
			if (user){
				showCollection.update({'users._id': ObjectID(id)},{$pull:{'users':{'_id':ObjectID(id)}}},{'multi':true,'w':0});
				movieCollection.update({'users._id': ObjectID(id)},{$pull:{'users':{'_id':ObjectID(id)}}},{'multi':true,'w':0});
				userCollection.remove({'_id':ObjectID(id)});
				deferred.resolve();
			}
			deferred.reject();
		});
		return deferred.promise;
	},
	update: function(id, data){
		var deferred = Q.defer(), self = this;
		
		if (!id) id = new ObjectID();
		
		if (data.password && data.passconf){
			if (data.password == data.passconf) {
				data.password = crypto.createHash('sha256').update(data.password).digest('hex');
			}
			delete data.passconf;
		}
		if (data.trakt) {
			if (data.hash) data.trakt.password = crypto.createHash('sha256').update(data.trakt.password).digest('hex');
			data.trakt = data.trakt;
		}
		if (data.mfa) {
			if (data.mfa.enabled){
				if (notp.totp.verify(data.mfa.confirm, data.mfa.secret.ascii)) {
					data.mfa.confirmed = true;
				} else {
					data.mfa.enabled = false;
				}
			} else {
				delete data.mfa.secret;
			}
			delete data.mfa.confirm;
		}
		userCollection.update({'_id':ObjectID(id)},{$set:data},{'upsert':true},function(error,affected,status){
			if (error){
				deferred.reject(error);
			}
			if (affected) deferred.resolve();
			
		});
		return deferred.promise;
	}
};
exports = module.exports = UserData;
