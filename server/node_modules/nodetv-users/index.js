'use strict';

var crypto		= require('crypto'),
	extend		= require('xtend'),
	log4js		= require('log4js'),
	notp		= require('notp'),
	ObjectID	= require('mongodb').ObjectID,
	Q			= require('q'),
	trakt	 	= new (require('nodetv-traktv2'))(nconf.get('trakt')),
	uuid		= require('node-uuid');

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-users');


var movieCollection = db.collection('movie'),
	showCollection = db.collection('show'),
	userCollection = db.collection('user');


var UserData = {
	add: function(admin,data){
		var deferred = Q.defer();
		if (admin.admin){
			var defaults = {
				'admin':false,
				'username':'',
				'password':'',
				'email':'',
				'trakt':{},
				'mfa':{
					'confirmed':false,
					'enabled':false,
					'secret': ''
				},
				'sessions':[]
			};
			
			if (data.password && data.passconf){
				if (data.password != '' && data.password == data.passconf){
					data.password = crypto.createHash('sha256').update(data.password).digest('hex');
				} else {
					delete data.password;
				}
				delete data.passconf;
			} else {
				delete data.password;
				delete data.passconf;
			}
			
			if (data.username && data.password){
				var record = extend({},defaults,data);
				userCollection.save(record, function(error,user){
					if (error){
						logger.debug(error);
						deferred.reject(error);
					}
					if (user){
						if (user.trakt.username && user.trakt.password){
							trakt.auth(user.trakt).token().then(function(json){
								user.trakt.token = json.token;
								userCollection.update({'_id':ObjectID(user._id)},{$set:{'trakt.token':json.token}},{'w':0});
								// TODO: sync show/movie data automatically
							//	shows.sync(user);
							});
						}
						deferred.resolve();
					}
					deferred.reject();
				});
				
			} else{
				deferred.reject();
			}
		} else {
			deferred.reject();
		}
		return deferred.promise;
	},
	
	check: function(session){
		var deferred = Q.defer();
		this.clean();
		userCollection.findOne({'sessions.session':session},{'password':false,'sessions':false,'mfa':false}, function(error, user){
			if (error){
				logger.error(error);
				deferred.reject();
			}
			if (user){
				deferred.resolve(user);
				userCollection.update({'sessions.session':session},{$set:{'sessions.$.timestamp':new Date()}},{'w':0});
			}
			deferred.reject();
		});
		return deferred.promise;
	},
	
	clean: function(days){
		if (typeof(days) == 'undefined') days = 7;
		var limit = new Date();
		limit.setDate(limit.getDate()-days);
		userCollection.update({},{$pull:{'sessions':{'timestamp':{$lte:limit}}}},{'multi':true,'w':0});
	},
	
	get: function(admin, id){
		var deferred = Q.defer();
		if (admin.admin || admin.username == id){
			userCollection.findOne({'username':id},{'password':false,'sessions':false},function(error,json){
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (json) deferred.resolve(json);
				deferred.reject();
			});
		} else {
			deferred.reject();
		}
		return deferred.promise;
	},
	
	list: function(admin){
		var deferred = Q.defer();
		if (admin.admin){
			userCollection.find({},{'password':false}).sort({'username':1}).toArray(function(error,users){
				if (error) deferred.reject(error);
				if (users) deferred.resolve(users);
				deferred.reject();
			});
		} else {
			deferred.reject();
		}
		return deferred.promise;
	},
	
	login: function(data){
		var deferred = Q.defer();
		data.hashed = crypto.createHash('sha256').update(data.password).digest('hex');
		userCollection.findOne({$or:[{'username':data.username},{'email':data.username}],'password':data.hashed},{'password':false,'sessions':false}, function(error,user){
			var response = {'error':false,'success':false,'session':null,'user':{}};
			if (error){
				logger.error(error);
				response.error = error;
				deferred.reject(response);
			}
			if (user){
				response.success = true;
				response.session = uuid.v4();
				if (user.trakt){
					trakt.auth(user.trakt).token().then(function(json){
						userCollection.update({'_id':ObjectID(user._id)},{$set:{'trakt.token':json.token}},{'w':0});
					});
					delete user.trakt;
				}
				response.user = user;
				
				var session = {
					'session': response.session,
					'timestamp': new Date()
				};
				userCollection.update({'_id':ObjectID(user._id)},{$addToSet:{'sessions':session}},{'w':0});
				deferred.resolve(response);
			}
			deferred.reject();
		});
		return deferred.promise;
	},
	logout: function(session, flush){
		var deferred = Q.defer();
		
		if (flush){
			var update = {$unset:{'sessions':true}};
		} else {
			var update = {$pull:{'sessions':{'session':session}}};
		}
		userCollection.update({'sessions.session':session}, update, {'w':0});
		deferred.resolve();
		
		return deferred.promise;
	},
	remove: function(admin, id){
		var deferred = Q.defer(), self = this;
		
		if (admin.admin){
			userCollection.findOne({$or:[{'username':id}]},function(error, user){
				if (error){
					logger.error(error);
					deferred.reject();
				}
				if (user){
					showCollection.update({'users._id': ObjectID(user._id)},{$pull:{'users':{'_id':ObjectID(user._id)}}},{'multi':true,'w':0});
					episodeCollection.update({'users._id': ObjectID(user._id)},{$pull:{'users':{'_id':ObjectID(user._id)}}},{'multi':true,'w':0});
					movieCollection.update({'users._id': ObjectID(user._id)},{$pull:{'users':{'_id':ObjectID(user._id)}}},{'multi':true,'w':0});
					
					userCollection.remove({'_id':ObjectID(user._id)});
					deferred.resolve();
				}
				deferred.reject();
			});
		} else {
			deferred.reject();
		}
		return deferred.promise;
	},
	update: function(admin, id, data){
		var deferred = Q.defer(), self = this;
		if (admin.admin || admin.username == id){
			data._id = ObjectID(data._id);
			if (data.password && data.passconf){
				if (data.password != '' && data.password == data.passconf){
					data.password = crypto.createHash('sha256').update(data.password).digest('hex');
				} else {
					delete data.password;
				}
				delete data.passconf;
			} else {
				delete data.password;
				delete data.passconf;
			}
			/*
			if (data.mfa){
				if (data.mfa.enabled){
					if (notp.totp.verify(data.mfa.confirm, data.mfa.secret.ascii)) {
						data.mfa.confirmed = true;
					} else {
						data.mfa.enabled = false;
					}
				} else {
					delete data.mfa.secret;
				}
				delete data.mfa.confirm;
			}
			*/
		//	logger.debug(data);
			userCollection.update({'username':id},{$set:data},{'upsert':true},function(error,affected){
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (affected) deferred.resolve();
				deferred.reject();
			});
		} else {
			deferred.reject();
		}
		return deferred.promise;
	}
};
exports = module.exports = UserData;
