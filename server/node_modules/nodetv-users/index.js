'use strict';

var crypto		= require('crypto'),
	log4js		= require('log4js'),
	notp		= require('notp'),
	ObjectID	= require('mongodb').ObjectID,
	Q			= require('q');

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-users');


var movieCollection = db.collection('movie'),
	showCollection = db.collection('show'),
	userCollection = db.collection('user');


var UserData = {
	add: function(){
		var deferred = Q.defer();
		// Create new user
		
		
		return deferred.promise;
	},
	get: function(id){
		var deferred = Q.defer();
		userCollection.findOne({'_id':ObjectID(id)},{'password':0}, function(error, json){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			
			if (!json) json = {_id: null};
			/*
			if (!json.mfa) {
				var secret = notp.totp.gen();
				json.mfa = {
					confirmed: false,
					enabled: false,
					secret: {
						ascii: secret,
						base32: ''
					}
				}
			} else if (!json.mfa.secret){
				json.mfa.secret.ascii = notp.totp.gen()
			}
			*/
			deferred.resolve(json);
		});
		return deferred.promise;
	},
	list: function(){
		var deferred = Q.defer();
		userCollection.find({},{'password':false}).sort({'username':1}).toArray(function(error,users){
			if (error) deferred.reject(error);
			if (users) deferred.resolve(users);
		});
		return deferred.promise;
	},
	remove: function(id){
		var self = this, deferred = Q.defer();
		userCollection.findOne({'_id':ObjectID(id)}, function(error, user){
			if (error) logger.error(error);
			if (user){
				showCollection.update({'users._id': ObjectID(id)},{$pull:{'users':{'_id':ObjectID(id)}}},{'multi':true,'w':0});
				movieCollection.update({'users._id': ObjectID(id)},{$pull:{'users':{'_id':ObjectID(id)}}},{'multi':true,'w':0});
				userCollection.remove({'_id':ObjectID(id)});
				deferred.resolve();
			}
		});
		return deferred.promise;
	},
	token: function(id, token){
		userCollection.update({'_id':ObjectID(id)},{$set:{'trakt.token':token}},{'w':0});
	},
	update: function(id, data){
		var deferred = Q.defer();
		
		if (!id) id = new ObjectID();
		
		if (data.password && data.passconf){
			if (data.password == data.passconf) {
				data.password = crypto.createHash('sha256').update(data.password).digest('hex');
			}
			delete data.passconf;
		}
		if (data.trakt) {
			if (data.hash) data.trakt.password = crypto.createHash('sha256').update(data.trakt.password).digest('hex');
			data.trakt = data.trakt;
		}
		if (data.mfa) {
			if (data.mfa.enabled){
				if (notp.totp.verify(data.mfa.confirm, data.mfa.secret.ascii)) {
					data.mfa.confirmed = true;
				} else {
					data.mfa.enabled = false;
				}
			} else {
				delete data.mfa.secret;
			}
			delete data.mfa.confirm;
		}
		userCollection.update({'_id':ObjectID(id)},{$set:data},{'upsert':true},function(error,affected,status){
			if (error){
				deferred.reject(error);
			}
			if (affected) deferred.resolve();
			
		});
		return deferred.promise;
	}
};
exports = module.exports = UserData;
