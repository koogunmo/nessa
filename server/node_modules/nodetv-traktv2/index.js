'use strict';

var crypto	= require('crypto'),
	extend	= require('xtend'),
	log4js	= require('log4js'),
	Q		= require('q'),
	qs		= require('querystring');

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-traktv2');

var urls = {
	'production': 'https://api.trakt.tv',
	'sandbox': 'https://api.v2.trakt.tv'
};
var api_url = urls.production;

var about = require('./package.json');

/******************************************************************************/

var TraktAPI = module.exports = function(config){
	this.defaults = {
		'client_id': null,
		'client_secret': null,
		'redirect_uri': 'urn:ietf:wg:oauth:2.0:oob'
	};
	this.settings = extend({}, this.defaults, config);
	this.options = {
		'followRedirect':false,
		'strictSSL':false,
		'gzip':true,
		'json':true,
		'headers':{
			'Cache-Control': 'no-cache, must-revalidate',
			'Content-type': 'application/json',
			'trakt-api-key': this.settings.client_id,
			'trakt-api-version': 2
		}
	};
	this.request = require('request').defaults(this.options);
	this.user = false;
};

/******************************************************************************/

TraktAPI.prototype.get = function(url, qs){
	var deferred = Q.defer(), options = {}, self = this;
	
	if (typeof(qs) == 'object') options.qs = qs;
	self.login().then(function(success){
		self.request.get(url, options, function(error,res,json){
			self.reset();
			if (error) deferred.reject(error);
			if (res && res.statusCode >= 400){
				deferred.reject({'status':res.statusCode,'error':res.headers.status,'url':url});
			}
			if (json) deferred.resolve(json);
		});
	});
	return deferred.promise;
};

TraktAPI.prototype.post = function(url, data){
	var deferred = Q.defer(), options = {}, self = this;
	if (!data.app_version) data.app_version = about.version;
	options.body = data;
	
	self.login().then(function(){
		self.request.post(url, options, function(error,res,json){
			self.reset();
			if (error) return deferred.reject(error);
			if (res && res.statusCode >= 400) {
				return deferred.reject({'status':res.statusCode,'error':res.headers.status});
			}
			if (json) deferred.resolve(json);
		});
	}, function(error){
		deferred.reject(error);
	})
	return deferred.promise;
};

/******************************************************************************/

TraktAPI.prototype.auth = function(user){
	this.user = user;
	return this;
};

TraktAPI.prototype.login = function(){
	var deferred = Q.defer(), self = this;
	if (this.user){
		if (this.user.token) {
			this.options.headers['trakt-user-login'] = this.user.username;
			this.options.headers['trakt-user-token'] = this.user.token;
			this.request = require('request').defaults(this.options);
			deferred.resolve();
		} else {
			this.token().then(function(success){
				self.user.token = json.token;
				self.options.headers['trakt-user-login'] = self.user.username;
				self.options.headers['trakt-user-token'] = self.user.token;
				self.request = require('request').defaults(self.options);
				deferred.resolve();
			}, function(error){
				deferred.reject();
			});
		}
	} else {
		deferred.resolve();
	}
	return deferred.promise;
};

TraktAPI.prototype.reset = function(){
	try {
		this.user = false;
		delete this.options.headers['trakt-user-login'];
		delete this.options.headers['trakt-user-token'];
		this.request = require('request').defaults(this.options);
	} catch(e){
		logger.error(e.message);
	}
};

TraktAPI.prototype.token = function(){
	var deferred = Q.defer(), self = this;
	
	this.request.post(api_url+'/auth/login', {'body':{'login':this.user.username,'password':this.user.password}}, function(error,res,json){
		if (error){
			logger.error(error);
			deferred.reject();
		}
		if (json){
			if (json.error) deferred.reject(json);
			if (json.token) deferred.resolve(json);
		}
	});
	return deferred.promise;
};

/******************************************************************************/

TraktAPI.prototype.genres = {
	'movies': function(){
		return self.get(api_url+'/genres/movies');
	},
	'shows': function(){
		return self.get(api_url+'/genres/shows');
	}
};

TraktAPI.prototype.movie = function(id){
	var self = this;
	return {
		'collected': function(status,time){
			status = (typeof(status) == 'undefined') ? true : status;
			if (typeof(time) == 'undefined') time = new Date();
			var payload = {
				'movies':[{'ids':{'imdb':id},'collected_at':time.toUTCString()}]
			};
			var endpoint = (status) ? '/sync/collection' : '/sync/collection/remove';
			return self.post(api_url+endpoint, payload);
		},
		'images': function(){
			return self.get(api_url+'/movies/'+id+'?extended=images');
		},
		'ratings': function(){
			return self.get(api_url+'/movies/'+id+'/ratings');
		},
		'search': function(){
			return self.get(api_url+'/search?type=movie&query='+query);
		},
		'summary': function(){
			return self.get(api_url+'/movies/'+id+'?extended=full');
		},
		'watched': function(status){
			status = (typeof(status) == 'undefined') ? true : status;
			var payload = {
				'movies':[{'ids':{'imdb':id}}]
			};
			var endpoint = (status) ? '/sync/history' : '/sync/history/remove';
			return self.post(api_url+endpoint, payload);
		},
		'watching': function(){
			return self.get(api_url+'/movies/'+id+'/watching');
		},
		'watchlist': function(status){
			status = (typeof(status) == 'undefined') ? true : status;
			var payload = {
				'movies':[{'ids':{'imdb':id}}]
			};
			var endpoint = (status) ? '/sync/watchlist' : '/sync/watchlist/remove';
			return self.post(api_url+endpoint, payload);
		}
	};
};

TraktAPI.prototype.search = function(type, query){
	return this.get(api_url+'/search?type='+type+'&query='+query);
};

TraktAPI.prototype.show = function(id){
	var self = this;
	return {
		'collected': function(status,time){
			status = (typeof(status) == 'undefined') ? true : status;
			if (typeof(time) == 'undefined') time = new Date();
			var payload = {
				'shows':[{'ids':{'imdb':id},'collected_at':time.toUTCString()}]
			};
			var endpoint = (status) ? '/sync/collection' : '/sync/collection/remove';
			return self.post(api_url+endpoint, payload);
		},
		'episode': function(season,episode){
			return {
				'collected': function(status,time){
					status = (typeof(status) == 'undefined') ? true : status;
					if (typeof(time) == 'undefined') time = new Date();
					var payload = {
						'shows':[{'ids':{'imdb':id},'seasons':[{'number':season,'episodes':[{'number':episode}]}],'collected_at':time.toUTCString()}]
					};
					var endpoint = (status) ? '/sync/collection' : '/sync/collection/remove';
					return self.post(api_url+endpoint, payload);
				},
				'summary': function(){
					return self.get(api_url+'/shows/'+id+'/seasons/'+season+'/episodes/'+episode+'?extended=full');
				},
				'watched': function(status){
					status = (typeof(status) == 'undefined') ? true : status;
					var payload = {
						'shows':[{'ids':{'imdb':id},'seasons':[{'number':season,'episodes':[{'number':episode}]}]}]
					};
					var endpoint = (status) ? '/sync/history' : '/sync/history/remove';
					return self.post(api_url+endpoint, payload);
				}
			};
		},
		'images': function(){
			return self.get(api_url+'/shows/'+id+'?extended=images');
		},
		'progress': {
			'collected': function(){
				return self.get(api_url+'/shows/'+id+'/progress/collection');
			},
			'watched': function(){
				return self.get(api_url+'/shows/'+id+'/progress/watched');
			}
		},
		'search': function(){
			return self.get(api_url+'/search?type=show&query='+query);
		},
		'season': function(season){
			return {
				'collected': function(status,time){
					status = (typeof(status) == 'undefined') ? true : status;
					if (typeof(time) == 'undefined') time = new Date();
					var payload = {
						'shows':[{'ids':{'imdb':id},'seasons':[{'number':season}],'collected_at':time.toUTCString()}]
					};
					var endpoint = (status) ? '/sync/collection' : '/sync/collection/remove';
					return self.post(api_url+endpoint, payload);
				},
				'episode': function(episode){
					return {
						'collected': function(status,time){
							status = (typeof(status) == 'undefined') ? true : status;
							if (typeof(time) == 'undefined') time = new Date();
							var payload = {
								'shows':[{'ids':{'imdb':id},'seasons':[{'number':season,'episodes':[{'number':episode}]}],'collected_at':time.toUTCString()}]
							};
							var endpoint = (status) ? '/sync/collection' : '/sync/collection/remove';
							return self.post(api_url+endpoint, payload);
						},
						'images': function(){
							return self.get(api_url+'/shows/'+id+'/seasons/'+season+'/episodes/'+episode+'?extended=images');
						},
						'summary': function(){
							return self.get(api_url+'/shows/'+id+'/seasons/'+season+'/episodes/'+episode+'?extended=full');
						},
						'watched': function(status){
							status = (typeof(status) == 'undefined') ? true : status;
							var payload = {
								'shows':[{'ids':{'imdb':id},'seasons':[{'number':season,'episodes':[{'number': episode}]}]}]
							};
							var endpoint = (status) ? '/sync/history' : '/sync/history/remove';
							return self.post(api_url+endpoint, payload);
						}
					}
				},
				'images': function(){
					return self.get(api_url+'/shows/'+id+'/seasons/'+season+'?extended=images');
				},
				'summary': function(){
					return self.get(api_url+'/shows/'+id+'/seasons/'+season+'?extended=full');
				},
				'watched': function(status){
					status = (typeof(status) == 'undefined') ? true : status;
					var payload = {
						'shows':[{'ids':{'imdb':id},'seasons':[{'number':season}]}]
					};
					var endpoint = (status) ? '/sync/history' : '/sync/history/remove';
					return self.post(api_url+endpoint, payload);
				}
			};
		},
		'seasons': function(){
			return self.get(api_url+'/shows/'+id+'/seasons?extended=full');
		},
		'summary': function(){
			return self.get(api_url+'/shows/'+id+'?extended=full');
		},
		'watched': function(status){
			status = (typeof(status) == 'undefined') ? true : status;
			var payload = {
				'shows':[{'ids':{'imdb':id}}]
			};
			var endpoint = (status) ? '/sync/history' : '/sync/history/remove';
			return self.post(api_url+endpoint, payload);
		},
		'watchlist': function(status){
			status = (typeof(status) == 'undefined') ? true : status;
			var payload = {
				'shows':[{'ids':{'imdb':id}}]
			};
			var endpoint = (status) ? '/sync/watchlist' : '/sync/watchlist/remove';
			return self.post(api_url+endpoint, payload);
		}
	};
};

TraktAPI.prototype.sync = function(){
	var self = this;
	return {
		'movies': {
			'collection': function(){
				return self.get(api_url+'/sync/collection/movies?extended=full');
			},
			'watchlist': function(){
				return self.get(api_url+'/sync/watchlist/movies?extended=full');
			}
		},
		'shows': {
			'collection': function(){
				return self.get(api_url+'/sync/collection/shows?extended=full');
			},
			'watchlist': function(){
				return self.get(api_url+'/sync/watchlist/shows?extended=full');
			}
		}
	};
};