'use strict';

var crypto	= require('crypto'),
	extend	= require('xtend'),
	log4js	= require('log4js'),
	Q		= require('q'),
	qs		= require('querystring'),
	request = null;

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-trakt');

var urls = {
	'production': 'https://trakt.tv',
	'sandbox': 'https://api.v2.trakt.tv'
};
var api_url = urls.production;

var about = require('./package.json');

/******************************************************************************/

var TraktAPI = module.exports = function(config){
	this.defaults = {
		'client_id': null,
		'client_secret': null,
		'redirect_uri': 'urn:ietf:wg:oauth:2.0:oob'
	};
	this.settings = extend({}, this.defaults, config);
	
	var defaults = {
		'followRedirect':false,
		'gzip':true,
		'headers':{
			'Content-type': 'application/json',
			'trakt-api-key': this.settings.client_id,
			'trakt-api-version': 2
		},
		'json':true,
		'strictSSL': false
	};
	request = require('request').defaults(defaults);
};

/******************************************************************************/

TraktAPI.prototype.get = function(url, qs){
	var deferred = Q.defer(), options = {}, self = this;
	if (typeof(qs) == 'object') options.qs = qs;
	
	this.login().then(function(){
		request.get(url, options, function(error,res,json){
			if (error) {
				logger.error(error);
				return deferred.resolve(error);
			}
			if (res && res.statusCode >= 400) {
				return deferred.reject({'status':res.statusCode,'error':res.headers.status});
			}
			if (json) deferred.resolve(json);
		});
	}, function(error){
		deferred.reject(error);
	})
	return deferred.promise;
};

TraktAPI.prototype.post = function(url, data){
	var deferred = Q.defer(), options = {'json':true}, self = this;
	if (!data.app_version) data.app_version = about.version;
	options.body = data;
	
	this.login().then(function(){
		request.post(url, options, function(error,res,json){
			if (error) {
				logger.error(error);
				return deferred.reject(error);
			}
			if (res && res.statusCode >= 400) {
				return deferred.reject({'status':res.statusCode,'error':res.headers.status});
			}
			if (json) deferred.resolve(json);
		});
	}, function(error){
		deferred.reject(error);
	})
	return deferred.promise;
};

/******************************************************************************/

TraktAPI.prototype.auth = function(user){
	this.user = user;
	return this;
};

TraktAPI.prototype.login = function(){
	var deferred = Q.defer(), self = this;
	request.post(api_url+'/auth/login', {'body':{'login':this.user.username,'password':this.user.password}}, function(error,res,json){
		if (error) {
			logger.error(error);
			return deferred.reject(error);
		}
		if (json){
			if (json.error){
				deferred.reject(json);
			} else {
				request.defaults({'trakt-user-login':self.user.username,'trakt-user-token':json.token});
				deferred.resolve(json);
			}
		}
	});
	return deferred.promise;
};

/******************************************************************************/

TraktAPI.prototype.genres = {
	'movies': function(){
		return self.get(api_url+'/genres/movies');
	},
	'shows': function(){
		return self.get(api_url+'/genres/shows');
	}
};

TraktAPI.prototype.movie = function(id){
	var self = this;
	return {
		'collected': function(){
			
		},
		'ratings': function(){
			return self.get(api_url+'/movies/'+id+'/ratings');
		},
		'search': function(){
			return self.get(api_url+'/search?type=movie&query='+query);
		},
		'summary': function(){
			return self.get(api_url+'/movies/'+id+'?extended=full,images');
		},
		'watched': function(){
			
		},
		'watching': function(){
			return self.get(api_url+'/movies/'+id+'/watching');
		}
	};
};

TraktAPI.prototype.search = function(type, query){
	return this.get(api_url+'/search?type='+type+'&query='+query);
};

TraktAPI.prototype.show = function(id){
	var self = this;
	return {
		'episode': function(season,episode){
			return {
				'collected': function(){
					
				},
				'summary': function(){
					return self.get(api_url+'/shows/'+id+'/season/'+season+'/episode/'+episode+'?extended=full');
				},
				'watched': function(){
					
				}
			};
		},
		'progress': {
			'collected': function(){
				return self.get(api_url+'/shows/'+id+'/progress/collection');
			},
			'watched': function(){
				return self.get(api_url+'/shows/'+id+'/progress/watched');
			}
		},
		'search': function(){
			return self.get(api_url+'/search?type=show&query='+query);
		},
		'season': function(season){
			return {
				'collected': function(){
					
				},
				'episode': function(episode){
					return {
						'collected': function(){
							
						},
						'summary': function(){
							return self.get(api_url+'/shows/'+id+'/season/'+season+'/episode/'+episode+'?extended=full');
						},
						'watched': function(){
							
						}
					}
				},
				'summary': function(){
					return self.get(api_url+'/shows/'+id+'/season/'+season+'?extended=full');
				},
				'watched': function(){
					
				}
			};
		},
		'seasons': function(){
			return self.get(api_url+'/shows/'+id+'/seasons?extended=full');
		},
		'summary': function(){
			return self.get(api_url+'/shows/'+id+'?extended=full,images');
		}
	};
};

TraktAPI.prototype.sync = {
	'movies': function(){
		return this.get(api_url+'/sync/collection/movies');
	},
	'shows': function(){
		return this.get(api_url+'/sync/collection/shows');
	}
};