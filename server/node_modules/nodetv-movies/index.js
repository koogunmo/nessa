var fs			= require('fs'),
	log4js		= require('log4js'),
	mkdir		= require('mkdirp'),
	ObjectID	= require('mongodb').ObjectID,
	path		= require('path'),
	Q			= require('q'),
	request		= require('request'),
	trakt		= new (require('nodetv-traktv2'))(nconf.get('trakt'));

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-moviedata');
var movieCollection = db.collection('movie'),
	unmatchedCollection = db.collection('unmatched'),
	userCollection = db.collection('user');

var torrent	= require('nodetv-transmission')(nconf.get('transmission'));

var MovieData = {
	add: function(user,imdb){
		var deferred = Q.defer(), self = this;
		var addMovie = function(json){
			try {
				var record = {
					'title': json.title,
					'year': parseInt(json.year,10),
					'url': json.ids.slug,
					'synopsis': json.overview,
					'released': new Date(json.released*1000),
					'runtime': parseInt(json.runtime,10),
					'imdb': json.ids.imdb,
					'tmdb': parseInt(json.ids.tmdb,10),
					'trakt': parseInt(json.ids.trakt,10),
					'genres': json.genres,
					'updated': new Date(json.updated_at)
				};
				movieCollection.update({'imdb':record.imdb},{$set:record},{'upsert':true}, function(error, affected){
					if (error){
						logger.error(error);
						deferred.reject(error);
					}
					if (affected){
						self.addUser(user,record.imdb);
						self.getArtwork(record.imdb);
						self.getHashes(record.imdb);
						deferred.resolve(record);
						
						trakt.auth(user.trakt).movie(record.imdb).watchlist(true);
					}
					deferred.reject();
				});
			} catch(e){
				logger.error('movie.add:', e.message);
			}
		};
		trakt.movie(imdb).summary().then(addMovie,function(error){
			logger.error(error);
			deferred.reject(error);
		});
		return deferred.promise;
	},
	complete: function(data){
		var deferred = Q.defer(), self = this;
		try {
			var hash = data.hash.toUpperCase();
			// Called when download is complete in Transmission
			movieCollection.findOne({$or:[{'hashes.hash':hash},{'hash':hash}]},function(error,movie){
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (movie){
					var exts = ['.avi','.mkv','.mp4','.wmv'], size = 0;
					
					var files = data.files.filter(function(file){
						if (exts.indexOf(path.extname(file.name)) == -1) return false;
						return true;
					});
					if (files.length != 1) return;
					
					var record = self.getFilename(movie, files[0].name);
					record.quality = movie.downloading;
					record.size = files[0].bytesCompleted;
					record.added = new Date();
					record.updated = new Date();
					
					if (movie.file){
						if (movie.file == record.file && !movie.downloading) return deferred.reject();
						if (movie.file != record.file) self.unlink(movie.imdb);
					}
					var basedir = nconf.get('media:base')+nconf.get('media:movies:directory');
					var source = data.dir+'/'+files[0].name, target = basedir+'/A-Z/'+record.file;
					
					helper.fileCopy(source, target).then(function(){
						deferred.resolve({'movie':movie,'trash':nconf.get('media:movies:autoclean')});
						movieCollection.update({'imdb':movie.imdb},{$set:record,$unset:{'downloading':true}},{'w':0});
						
						if (movie.users){
							movie.users.forEach(function(u){
								userCollection.findOne({'_id':ObjectID(u._id),'trakt':{$exists:true}},function(error,user){
									if (error) logger.error(error);
									if (user.trakt){
										logger.debug('Collecting:', movie.title, user.username);
										trakt.auth(user.trakt).movie(movie.imdb).collected(true);
									}
								});
							});
						}
					}, function(error){
						logger.error(error);
						deferred.reject(error);
					});
				} else {
					deferred.reject();
				}
			});
		} catch(e){
			deferred.reject(e.message);
		}
		return deferred.promise;
	},
	download: function(user, imdb, data){
		var deferred = Q.defer(), self = this;
		movieCollection.findOne({'imdb':imdb}, function(error, movie){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (movie){
				torrent.add(helper.createMagnet(data.hash), function(error,args){
					if (error) {
						logger.error(error);
						deferred.reject(error);
					}
					if (args.hashString){
						movieCollection.update({'imdb':imdb},{$set:{'downloading':data.quality,'hash':args.hashString.toUpperCase()}},{'w':0});
						deferred.resolve(movie);
					}
					deferred.reject();
				});
			} else {
				deferred.reject();
			}
		});
		return deferred.promise;
	},
	get: function(user,imdb){
		var deferred = Q.defer(), self = this;
		movieCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)}, function(error,movie){
			if (error) logger.error(error);
			if (movie) deferred.resolve(movie);
			deferred.reject();
		});
		return deferred.promise;
	},
	latest: function(user){
		var deferred = Q.defer(), self = this;
		movieCollection.find({'file':{$exists:true},'users._id':ObjectID(user._id)}).sort({'added':-1}).limit(20).toArray(function(error,results){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (results) deferred.resolve(results);
			deferred.reject();
		});
		return deferred.promise;
	},
	link: function(imdb){
		var deferred = Q.defer(), self = this;
		movieCollection.findOne({'imdb':imdb}, function(error, movie){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (movie){
				var basedir = nconf.get('media:base')+nconf.get('media:movies:directory');
				movie.genres.forEach(function(genre){
					genre.replace('-',' ').capitalize();
					var folder = basedir +'/Genres/'+genre, symlink = path.basename(movie.file);
					if (!fs.existsSync(folder)) mkdir.sync(folder,0775);
					if (!symlink || fs.existsSync(folder+'/'+symlink)) return;
					fs.symlink(basedir+'/A-Z/'+movie.file, folder+'/'+symlink, 'file', function(error){
						if (error) return logger.error(error);
						logger.debug('Linked: %s/%s', genre, movie.file);
					});
				});
				deferred.resolve(movie)
			} else {
				deferred.reject();
			}
		});
		return deferred.promise;
	},
	list: function(user){
		var deferred = Q.defer();
		movieCollection.find({'imdb':{$exists: true},'users._id':ObjectID(user._id)}).sort({'name':1}).toArray(function(error,results){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (results) deferred.resolve(results);
			deferred.reject();
		});
		return deferred.promise;
	},
	match: function(user, matches){
		var deferred = Q.defer(), self = this;
		
		matches.forEach(function(match){
			movieCollection.update({'imdb':match.imdb},{'file':match.file},{'upsert':true}, function(error,affected){
				if (error) logger.error(error);
				if (affected){
					self.add(user, match.imdb).then(function(result){
						if (result){
							self.rename(user, imdb, match.file, self.getQuality(match.file));
							deferred.resolve();
						}
						deferred.reject();
					});
				}
			})
		});
		return deferred.promise;
	},
	pending: function(user){
		var deferred = Q.defer();
		movieCollection.find({'file':{$exists:false},'hashes':{$exists:true}}).sort({'updated':-1}).toArray(function(error,results){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (results) deferred.resolve(results);
			deferred.reject();
		});
		return deferred.promise;
	},
	remove: function(user, imdb){
		var deferred = Q.defer(), physical = false, self = this;
		movieCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)}, function(error,movie){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (movie){
				if (physical){
					self.unlink(imdb, function(error){
						movieCollection.remove({'imdb':imdb},{'w':0});
						deferred.resolve();
					});
				} else {
					var update = {$pull:{'users':{'_id':ObjectID(user._id)}}};
					if (movie.users.length == 1) update.$set = {'status': false};
					movieCollection.update({'imdb':movie.imdb},update,{'w':0});
					deferred.resolve();
				}
			} else {
				deferred.reject(error);
			}
		});
		return deferred.promise;
	},
	rename: function(user, imdb, file, quality){
		var deferred = Q.defer(), self = this;
		var basedir = nconf.get('media:base') + nconf.get('media:movies:directory');
		movieCollection.findOne({'imdb':imdb}, function(error, movie){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (movie){
				var record = self.getFilename(movie,file), target = basedir+'/A-Z/'+record.file;
				if (target != file){
					// Let's not move files that are already in the right place
					if (fs.existsSync(path.dirname(target))) mkdir.sync(path.dirname(target),0775);
					helper.fileMove(file, target, function(error){
						if (error){
							logger.error(error);
							deferred.reject(error);
						} else {
							movieCollection.update({'imdb':imdb},{$set:record},function(error, affected){
								if (error) logger.error(error);
								if (affected) self.link(movie.imdb);
							});
							deferred.resolve(movie.imdb);
							trakt.auth(user.trakt).movie(movie.imdb).collected(true);
						}
					});
				}
			}
			deferred.reject();
		});
		return deferred.promise;
	},
	search: function(user,query){
		return trakt.search('movie', query);
	},
	scan: function(user, callback){
		var deferred = Q.defer(), self = this;
		logger.debug('Scanning movie library...');
		
		var insertMovie = function(imdb,file){
			
			return false;
			
			self.add(user,imdb).then(function(movie){
				if (movie){
					self.rename(user, movie.imdb, file.path, self.getQuality(path.basename(file.path)));
					movieCollection.update({'imdb':movie.imdb},{$set:{'added':new Date(file.stat.mtime),'size':parseInt(file.stat.size,10)}},{'w':0});
					trakt.auth(user.trakt).movie(movie.imdb).library(true);
					if (typeof(callback) == 'function') callback(null, movie.imdb);
				}
			},function(error){
				logger.debug(error);
			});
		};
		
		var base =  nconf.get('media:base') + nconf.get('media:movies:directory') + '/A-Z'
		helper.listDirectory(base, function(error, file){
			if (error) logger.error(error);
			if (file.stat.isSymbolicLink()) return;
			var ext = path.extname(file.path), name = path.basename(file.path, ext),
				offset = 0, quality = '480p', title = '', year = 0;
			
			if (name.match(/^(.+)\s?(\([\d]{4}\)|\[[\d]{4}\])/i)){
				var matched = name.match(/^(.+)\s?(\([\d]{4}\)|\[[\d]{4}\])/i);
				title = matched[1].trim(), year = parseInt(matched[2].replace(/\D/, ''));
			} else {
				// Guesswork time...
				name = name.replace(/\W/g, ' ');
				var numbers = name.match(/(\d{4})/g);
				if (numbers){
					numbers.forEach(function(number){
						if (parseInt(number,10) >= 1887){
							// If you're wondering 'Why 1887?': (http://www.imdb.com/title/tt2075247/)
							year = parseInt(number, 10);
							offset = name.indexOf(number);
						}
					});
					if (offset > 0) title = name.substring(0, offset).trim();
				} else {
					title = name.trim();
				}
			}
			quality = self.getQuality(name);
			
			var stats = {
				'added': file.stat.mtime,
				'size': parseInt(file.stat.size,10)
			};
			if (title.match(', The')) title = 'The '+title.replace(', The', '');
			
			var filename = file.path.replace(base,'');
			movieCollection.findOne({$or:[{'file':filename},{'title':title}]}, function(error,movie){
				if (error) logger.error(error);
				if (movie){
					// Already in collection
				//	logger.info('Found:', movie.title);
				} else {
					logger.warn('Searching for:', title);
					trakt.search('movie', title).then(function(results){
						var unmatched = null;
						if (results){
							if (results.length == 1){
								logger.debug(results[0].title);
							//	insertMovie(results[0].ids.imdb, file);
							} else {
								var filtered = results.filter(function(result){
									var include = true;
									if (year && result.year != year || !result.year) include = false;
									if (title) {
										title.split(' ').forEach(function(word){
											if (result.title.toLowerCase().indexOf(word.toLowerCase()) == -1) include = false;
										});
									}
									return include;
								});
								if (filtered.length == 1){
									logger.debug(filtered[0].title)
								//	insertMovie(filtered[0].ids.imdb, file);
								} else {
									unmatched = {'type':'movie','file':filename,'matches':filtered};
								}
							}
						} else {
							unmatched = {'type':'movie','file':filename};
						}
						if (unmatched){
							logger.debug(unmatched);
						//	unmatchedCollection.update({'type':'movie','file':filename},{$set:unmatched},{'upsert':true,'w':0});
						}
					},function(error){
						logger.error(error);
					});
				}
			});
		});
	},
	sync: function(user){
		var deferred = Q.defer(), self = this;
		
		var syncMovies = function(results){
			try {
				var movies = [];
				for (var i in results){movies.push(results[i].movie)}
				
				if (movies.length){
					movies.forEach(function(movie){
						var record = {
							'title': movie.title,
							'year': parseInt(movie.year,10),
							'url': movie.ids.slug,
							'synopsis': movie.overview,
							'released': new Date(movie.released),
							'runtime': parseInt(movie.runtime,10),
							'imdb': movie.ids.imdb,
							'tmdb': parseInt(movie.ids.tmdb,10),
							'trakt': parseInt(movie.ids.trakt,10),
							'genres': movie.genres,
							'updated': new Date(movie.updated_at)
						};
						movieCollection.update({'imdb':record.imdb},{$set:record},{'upsert':true},function(error,affected){
							if (error) logger.error(error);
							if (affected){
								self.addUser(user,record.imdb);
								self.getArtwork(record.imdb);
							}
						});
					});
				}
			} catch(e){
				logger.error(e.message);
			}
		};
		logger.debug('Syncing movies...');
		
		trakt.auth(user.trakt).sync().movies.collection().then(function(movies){
			socket.emit('alert', {'title':'Movies','message':'Syncing collection...'});
			syncMovies(movies);
		}, function(error){
			logger.error(error);
		});
		trakt.auth(user.trakt).sync().movies.watchlist().then(function(movies){
			socket.emit('alert', {'title':'Movies','message':'Syncing watchlist...'});
			syncMovies(movies);
		});
		return deferred.promise;
	},
	
	unlink: function(imdb){
		var deferred = Q.defer(), self = this
		movieCollection.findOne({'imdb':imdb},function(error, movie){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}	
			if (movie){
				var basedir = nconf.get('media:base')+nconf.get('media:movies:directory');
				if (movie.file && movie.genres){
					var filename = path.basename(movie.file);
					movie.genres.forEach(function(genre){
						genre = genre.replace('-',' ').capitalize();
						fs.unlink(basedir+'/Genres/'+genre+'/'+filename, function(error){
							if (error) return logger.error(error);
							logger.debug('Unlinked: %s/%s', genre, filename)
						});
					});
					deferred.resolve(movie);
				}
			}
			deferred.reject();
		});
		return deferred.promise;
	},
	
	
	watched: function(user,imdb){
		
		
		
	},
	
	/*****  *****/
	
	addUser: function(user,imdb){
		var deferred = Q.defer(), self = this;
		
		var addUser = function(record){
			movieCollection.update({'imdb':imdb},record,function(error,affected){
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (affected) deferred.resolve();
				deferred.reject();
			});
		};
		
		movieCollection.findOne({'imdb':imdb},function(error,movie){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (movie){
				var record = {'_id':ObjectID(user._id),'username':user.username};
				if (movie.users){
					var users = movie.users.filter(function(u){
						if (ObjectID(user._id).equals(u._id)) return true;
						return false;
					});
					if (users.length){
						deferred.resolve();
					} else {
						addUser({$addToSet:{'users':record}});
					}
				} else {
					addUser({$set:{'users':[record]}})
				}
			} else {
				deferred.reject();
			}
		});
		return deferred.promise;
	},
	clearSymlinks: function(){
		var deferred = Q.defer(), self = this;
		var directory = nconf.get('media:base')+nconf.get('media:movies:directory')+'/Genres';
		
		helper.listDirectory(directory, function(error,file){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (file.stat){
				if (file.stat.isSymbolicLink()){
					logger.debug('Unlinked: ', file.path);
					fs.unlink(file.path);
				}
			}
		});
		deferred.resolve();
		return deferred.promise;
	},
	countUnmatched: function(){
		var deferred = Q.defer();
		unmatchedCollection.count({'type':'movie'}, function(error,count){
			if (error){
				logger.error(error);
				deferred.reject();
			}
			deferred.resolve(count);
		});
		return deferred.promise;
	},
	rebuildGenres: function(){
		var deferred = Q.defer(), self = this;
		
		this.clearSymlinks().then(function(){
			movieCollection.find({'file':{$exists:true},'genres':{$exists:true}},{'imdb':1}).toArray(function(error,movies){
				if (error){
					logger.error(error);
					deferred.reject(error);
				}
				if (movies){
					movies.forEach(function(movie){
						self.link(movie.imdb);
					});
					deferred.resolve();
				}
				deferred.reject();
			});
		});
		return deferred.promise;
	},
	
	getAlpha: function(name){
		var title = name.replace(/^The\s/, '').trim(), alpha = title.substr(0,1).toUpperCase();
		if (alpha.match(/\d/)) alpha = '#';
		return alpha; 
	},
	getArtwork: function(imdb){
		var deferred = Q.defer(), self = this;
		
		movieCollection.findOne({'imdb':imdb},function(error,movie){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (movie){
				logger.debug('Getting Artwork:', movie.title);
				var directory = nconf.get('media:base')+nconf.get('media:movies:directory')+'/.artwork/'+movie.imdb;
				if (!fs.existsSync(directory)) mkdir.sync(directory);
				
				trakt.movie(movie.imdb).images().then(function(json){
					if (json.images){
						if (json.images.poster.thumb){
							try {
								var poster = fs.createWriteStream(directory+'/poster.jpg', {'flags':'w','mode':0664});
								poster.on('error', function(e){
									logger.error(e);
								});
								request.get({'uri':json.images.poster.thumb}).pipe(poster);
							} catch(e){
								logger.error(e.message);
							}
						}
						if (json.images.banner.full){
							try {
								var poster = fs.createWriteStream(directory+'/banner.jpg', {'flags':'w','mode':0664});
								poster.on('error', function(e){
									logger.error(e);
								});
								request.get({'uri':json.images.banner.full}).pipe(poster);
							} catch(e){
								logger.error(e.message);
							}
						}
					//	movieCollection.update({'imdb':movie.imdb},{$set:{'images':json.images}},{'w':0});
					}
					deferred.resolve(movie);
				}, function(error){
					logger.error(error);
					deferred.reject(error);
				});
			} else {
				deferred.reject();
			}
		});
		return deferred.promise;
	},
	getFilename: function(movie, file){
		var self = this;
		var alpha = self.getAlpha(movie.title), blocks = [], ext = path.extname(file), quality = self.getQuality(file), record = {status: true};
		blocks.push(movie.title.replace(/[\\\/\[\]]/ig, ''));
		blocks.push('('+movie.year+')');
		if (movie.downloading || movie.quality || quality) {
			record.quality = movie.downloading || movie.quality || quality;
			blocks.push('['+record.quality+']')
		}
		record.file = alpha+'/'+blocks.join(' ')+ext;
		return record;
	},
	getGenres: function(){
		return trakt.genres().movies();
	},
	getHashes: function(imdb){
		var deferred = Q.defer(), self = this;
		
		var req = {
			'url': 'https://yts.wf/api/listimdb.json',
			'method': 'GET',
			'json': true,
			'qs': {'imdb_id':imdb}
		};
		if (nconf.get('system:proxy')) {
			req.tunnel = true;
			req.proxy = nconf.get('system:proxy');
		}
		
		request(req, function(error, res, json){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (json){
				var torrents = [];
				try {
					if (typeof(json) != 'object') json = JSON.parse(json);
					if (json.status == 'fail'){
						deferred.reject(json);
					} else if (json.MovieCount){
						json.MovieList.forEach(function(result){
							var object = {
								'hash': result.TorrentHash.toUpperCase(),
								'quality': result.Quality,
								'size': parseInt(result.SizeByte,10)
							};
							torrents.push(object);
						});
						
						if (torrents.length) {
							var update = {
								'hashes': torrents,
								'updated': new Date()
							};
							movieCollection.update({'imdb':imdb},{$set:update},{'w':0});
							deferred.resolve(torrents);
						}
					}
				} catch(e){
					logger.error(e.message);
					deferred.reject(e.message);
				}
				deferred.reject();
			}
		});
		return deferred.promise;
	},
	getLatest: function(){
		var deferred = Q.defer();
		
		var req = {
			'url': 'https://yts.wf/api/list.json',
			'method': 'GET',
			'json': true,
			'qs': {'limit': 25}
		};
		if (nconf.get('system:proxy')) {
			req.tunnel = true;
			req.proxy = nconf.get('system:proxy');
		}
		
		request(req, function(error,res,json){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (json){
				try {
					if (typeof(json) != 'object') json = JSON.parse(json);
					if (json.status == 'fail'){
						deferred.reject(json);
					} else if (json.MovieCount){
						json.MovieList.forEach(function(result){
							var object = {
								'hash': result.TorrentHash.toUpperCase(),
								'quality': result.Quality,
								'size': parseInt(result.SizeByte,10)
							};
							movieCollection.update({'imdb':result.ImdbCode},{$set:{'updated':new Date()},$addToSet:{'hashes':object}},{'w':0});
						});
						deferred.resolve();
					}
				} catch(e){
					logger.error(e.message);
					deferred.reject(e.message);
				}
			}
			deferred.reject();
		});
		return deferred.promise;
	},
	getQuality: function(file){
		var quality = '480p';
		if (file.match(/(1080p|720p|480p)/i)) quality = file.match(/(1080p|720p|480p)/i)[1];
		return quality;
	},
	getUnhashed: function(){
		var deferred = Q.defer(), self = this;
		movieCollection.find({'hashes':{$exists:false}},{'imdb':true}).toArray(function(error, movies){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (movies){
				movies.forEach(function(movie){
					self.getHashes(movie.imdb);
				});
				deferred.resolve();
			}
			deferred.reject();
		});
		return deferred.promise;
	},
	getUnmatched: function(){
		var deferred = Q.defer();
		unmatchedCollection.find({type: 'movie'}).sort({title:1}).limit(20).toArray(function(error,results){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (results) deferred.resolve(results);
			deferred.reject();
		});
		return deferred.promise;
	},
	
	cleanHashes: function(){
		var deferred = Q.defer(), self = this;
		movieCollection.find({'hashes':{$exists:true}},{'imdb':true}).toArray(function(error,movies){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (movies){
				logger.debug('Updating movie hashes')
				movies.forEach(function(movie){
					self.getHashes(movie.imdb)
				});
				deferred.resolve();
			}
			deferred.reject();
		});
		return deferred.promise;
	}
};
exports = module.exports = MovieData;