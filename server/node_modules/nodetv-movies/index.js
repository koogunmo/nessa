'use strict';

var fs			= require('fs'),
	log4js		= require('log4js'),
	mkdirp		= require('mkdirp'),
	ObjectID	= require('mongodb').ObjectID,
	path		= require('path'),
	Q			= require('q'),
	request		= require('request'),
	trakt		= new (require('nodetv-traktv2'))(nconf.get('trakt'));

log4js.configure({
	appenders: [{
		type: 'console'
	}],
	replaceConsole: true
});
var logger = log4js.getLogger('nodetv-moviedata');
var movieCollection = db.collection('movie'),
	unmatchedCollection = db.collection('unmatched'),
	userCollection = db.collection('user');

var torrent	= require('nodetv-transmission')(nconf.get('transmission'));

var MovieData = {
	add: function(user,imdb,callback){
		var deferred = Q.defer(), self = this;
		var addMovie = function(json){
			try {
				var record = {
					'title': json.title,
					'year': parseInt(json.year,10),
					'url': json.ids.slug,
					'synopsis': json.overview,
					'released': new Date(json.released*1000),
					'runtime': parseInt(json.runtime,10),
					'imdb': json.ids.imdb,
					'tmdb': parseInt(json.ids.tmdb,10),
					'trakt': parseInt(json.ids.trakt,10),
					'genres': json.genres,
					'added': new Date(),
					'updated': new Date(json.updated_at)
				};
				movieCollection.update({'imdb':record.imdb},{$set:record},{'upsert':true}, function(error, affected){
					if (error){
						logger.error(error);
						deferred.reject(error);
					}
					if (affected){
						self.getArtwork(record.imdb);
						self.getHashes(record.imdb);
						self.addUser(user,record.imdb);
						deferred.resolve(record);
						
						trakt.auth(user.trakt).movie(record.imdb).watchlist(true);
					}
					if (typeof(callback) == 'function') callback(error, record);
				});
			} catch(e){
				logger.error('movie.add:', e.message);
			}
		};
		trakt.movie(imdb).summary().then(addMovie,function(error){
			logger.error(error);
		});
		return deferred.promise;
	},
	complete: function(data, callback){
		var deferred = Q.defer(), self = this;
		try {
			var hash = data.hash.toUpperCase();
			// Called when download is complete in Transmission
			movieCollection.findOne({$or:[{'hashes.hash':hash},{'hash':hash}]},function(error,movie){
				if (error) logger.error(error);
				if (movie){
					var exts = ['.avi','.mkv','.mp4'], size = 0;
					
					var files = data.files.filter(function(file){
						if (exts.indexOf(path.extname(file.name)) == -1) return false;
						return true;
					});
					if (files.length != 1) return;
					
					var record = self.getFilename(movie, files[0].name);
					record.quality = movie.downloading;
					record.size = files[0].bytesCompleted;
					record.added = new Date();
					record.updated = new Date();
					
					if (movie.file){
						if (movie.file == record.file && !movie.downloading) return false;
						if (movie.file != record.file) self.unlink(movie.imdb);
					}
					var basedir = nconf.get('media:base')+nconf.get('media:movies:directory');
					var source = data.dir+'/'+files[0].name, target = basedir+'/A-Z/'+record.file;
					
					helper.fileCopy(source, target, function(error){
						if (error) {
							logger.error(error);
							deferred.reject(error);
						} else {
							movieCollection.update({'imdb':movie.imdb},{$set:record,$unset:{'downloading':true}},function(error, affected){
								if (error) {
									logger.error(error);
									deferred.reject(error);
								} else {
									self.link(movie)
									deferred.resolve(movie);
								}
							});
							if (movie.users){
								movie.users.forEach(function(u){
									userCollection.findOne({'_id':ObjectID(u._id),'trakt':{$exists:true}},{'trakt':1},function(error,user){
										if (error) logger.error(error);
										if (user.trakt) trakt.auth(user.trakt).movie(movie.imdb).collected(true);
									});
								});
							}
						}
						if (typeof(callback) == 'function') callback(error, {'movie':movie,'trash':nconf.get('media:movies:autoclean')})
					});
				}
			});
		} catch(e){
			deferred.reject(e.message);
		}
		return deferred.promise;
	},
	download: function(user, imdb, data, callback){
		var deferred = Q.defer(), self = this;
		movieCollection.findOne({'imdb':imdb}, function(error, movie){
			if (error) logger.error(error);
			if (movie){
				torrent.add(helper.createMagnet(data.hash), function(error, args){
					if (error) {
						logger.error(error);
						deferred.reject(error);
					}
					if (args.hashString){
						movieCollection.update({'imdb':imdb},{$set:{'downloading':data.quality,'hash':args.hashString.toUpperCase()}}, {w:0});
						deferred.resolve(movie);
					}
					if (typeof(callback) == 'function') callback(error, movie);
				});
			}
		});
		return deferred.promise;
	},
	get: function(user,imdb){
		var deferred = Q.defer(), self = this;
		movieCollection.findOne({'imdb':imdb}, function(error,movie){
			if (error) logger.error(error);
			if (movie) deferred.resolve(movie);
		});
		return deferred.promise;
	},
	latest: function(user, callback){
		var deferred = Q.defer(), self = this;
		// List the most recently added movies (TODO: filter by user)
		movieCollection.find({'file':{$exists:true},'users._id':ObjectID(user._id)}).sort({'added':-1}).limit(20).toArray(function(error,results){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}
			if (results) deferred.resolve(results);
			if (typeof(callback) == 'function') callback(error,results);
		});
		return deferred.promise;
	},
	link: function(imdb, callback){
		var deferred = Q.defer(), self = this;
		movieCollection.findOne({'imdb':imdb}, function(error, movie){
			if (error) {
				logger.error(error);
				deferred.reject(error);
				return;
			}
			var basedir = nconf.get('media:base')+nconf.get('media:movies:directory');
			movie.genres.forEach(function(genre){
				var folder = basedir +'/Genres/'+genre, symlink = path.basename(movie.file);
				if (!fs.existsSync(folder)) mkdirp.sync(folder, 775);
				if (!symlink || fs.existsSync(folder+'/'+symlink)) return;
				fs.symlink(basedir+'/A-Z/'+movie.file, folder+'/'+symlink, 'file', function(error){
					if (error) logger.error(error);
				});
			});
			deferred.resolve(movie.genres);
			if (typeof(callback) == 'function') callback(movie.genres);
		});
		return deferred.promise;
	},
	list: function(user, callback){
		// List all movies (TODO: by user)
		movieCollection.find({'imdb':{$exists: true},'users._id':ObjectID(user._id)}).sort({'name':1}).toArray(callback);
	},
	match: function(user, matches, callback){
		var self = this, deferred = Q.defer();
		matches.forEach(function(match){
			movieCollection.update({'imdb':match.imdb},{'file':match.file},{'upsert':true}, function(error,affected){
				if (error) logger.error(error);
				if (affected){
					self.add(user, match.imdb).then(function(result){
						if (result) {
							self.rename(user, imdb, match.file, self.getQuality(match.file));
							deferred.resolve();
						}
					});
				}
			})
		});
		return deferred.promise;
	},
	pending: function(user, callback){
		// Movies awaiting human intervention
		movieCollection.find({'file':{$exists:false},'hashes':{$exists:true}}).sort({'updated':-1}).toArray(callback);
	},
	remove: function(user, imdb, callback){
		var deferred = Q.defer(), self = this;
		var physical = false;
		
		movieCollection.findOne({'imdb':imdb,'users._id':ObjectID(user._id)}, function(error,movie){
			if (error) logger.error(error);
			if (movie){
				if (physical){
					self.unlink(imdb, function(error){
						movieCollection.remove({'imdb':imdb}, {w:0});
						deferred.resolve();
					});
				} else {
					var update = {$pull:{'users':{'_id':ObjectID(user._id)}}};
					if (show.users.length == 1) update.$set = {'status': false};
					movieCollection.update({'imdb':movie.imdb},update,{'w':0});
					deferred.resolve();
				}
			} else {
				deferred.reject(error);
			}
		});
		return deferred.promise;
	},
	rename: function(user, imdb, file, quality, callback){
		var deferred = Q.defer(), self = this;
		var basedir = nconf.get('media:base') + nconf.get('media:movies:directory');
		movieCollection.findOne({'imdb':imdb}, function(error, movie){
			if (error) {
				logger.error(error);
				deferred.reject(error);
			}
			if (movie){
				var record = self.getFilename(movie,file), target = basedir+'/A-Z/'+record.file;
				if (target != file){
					// Let's not move files that are already in the right place
					if (fs.existsSync(path.dirname(target))) mkdirp.sync(path.dirname(target));
					helper.fileMove(file, target, function(error){
						if (error) return logger.error(error);
						movieCollection.update({'imdb':imdb},{$set:record},function(error, affected){
							if (error) logger.error(error);
							if (affected) self.link(movie.imdb);
						});
						deferred.resolve(movie.imdb);
						trakt.auth(user.trakt).movie(movie.imdb).collected(true);
					});
				}
			}
			if (typeof(callback) == 'function') callback(error);
		});
		return deferred.promise;
	},
	search: function(user, query, callback){
		if (!user.trakt) return;
		try {
			trakt.search('movies', query, callback);
		} catch(e){
			logger.error(e.message);
		}
	},
	scan: function(user, callback){
		var self = this;
		logger.debug('Scanning movie library...');
		
		var insertMovie = function(imdb,file){
			self.add(user,imdb).then(function(movie){
				if (movie){
					self.rename(user, movie.imdb, file.path, self.getQuality(path.basename(file.path)));
					movieCollection.update({'imdb':movie.imdb},{$set:{'added':file.stat.mtime,'size':parseInt(file.stat.size,10)}},{'w':0});
					trakt.auth(user.trakt).movie(movie.imdb).library(true);
					if (typeof(callback) == 'function') callback(null, movie.imdb);
				}
			},function(error){
				logger.debug(error);
			});
		};
		
		var base =  nconf.get('media:base') + nconf.get('media:movies:directory') + '/A-Z'
		helper.listDirectory(base, function(error, file){
			if (error) logger.error(error);
			if (file.stat.isSymbolicLink()) return;
			var ext = path.extname(file.path), name = path.basename(file.path, ext),
				offset = 0, quality = '480p', title = '', year = 0;
			
			if (name.match(/^(.+)\s?(\([\d]{4}\)|\[[\d]{4}\])/i)){
				var matched = name.match(/^(.+)\s?(\([\d]{4}\)|\[[\d]{4}\])/i);
				title = matched[1].trim(), year = parseInt(matched[2].replace(/\D/, ''));
			} else {
				// Guesswork time...
				name = name.replace(/\W/g, ' ');
				var numbers = name.match(/(\d{4})/g);
				if (numbers){
					numbers.forEach(function(number){
						if (parseInt(number,10) >= 1887){
							// If you're wondering 'Why 1887?': (http://www.imdb.com/title/tt2075247/)
							year = parseInt(number, 10);
							offset = name.indexOf(number);
						}
					});
					if (offset > 0) title = name.substring(0, offset).trim();
				} else {
					title = name.trim();
				}
			}
			quality = self.getQuality(name);
			
			var stats = {
				added: file.stat.mtime,
				size: parseInt(file.stat.size,10)
			};
			if (title.match(', The')) title = 'The '+title.replace(', The', '');
			
			var filename = file.path.replace(base,'');
			movieCollection.findOne({$or:[{'file':filename},{'title':title}]}, function(error,movie){
				if (error) logger.error(error);
				if (movie){
					// Already in database
				//	logger.info('Found:', movie.title);
				} else {
					logger.warn('Searching for:', title);
					trakt.search('movies', title).then(function(results){
						var unmatched = null;
						if (results){
							if (results.length == 1){
								insertMovie(results[0].ids.imdb, file);
							} else {
								var filtered = results.filter(function(result){
									var include = true;
									if (year && result.year != year || !result.year) include = false;
									if (title) {
										title.split(' ').forEach(function(word){
											if (result.title.toLowerCase().indexOf(word.toLowerCase()) == -1) include = false;
										});
									}
									return include;
								});
								if (filtered.length == 1){
									insertMovie(filtered[0].imdb_id, file);
								} else {
									unmatched = {'type':'movie','file':filename,'matches':filtered};
								}
							}
						} else {
							unmatched = {'type':'movie','file':filename};
						}
						if (unmatched) unmatchedCollection.update({'type':'movie','file':filename},{$set:unmatched},{'upsert':true,'w':0});
					},function(error){
						logger.error(error);
					});
				}
			});
		});
	},
	sync: function(user, callback){
		// Retrive movie list from trakt
		var deferred = Q.defer(), self = this;
		try {
			
			return;
			
			trakt.auth(user.trakt).sync('movies').then(function(movies){
				logger.debug('Syncing movie library...');
				logger.debug('Movie Library: ', movies.length);
				movies.forEach(function(movie){
					var record = {
						'title': movie.title,
						'year': parseInt(movie.year,10),
						'url': movie.url.split('/').pop(),
						'synopsis': movie.overview,
						'released': new Date(movie.released*1000),
						'runtime': parseInt(movie.runtime,10),
						'imdb': movie.imdb_id,
						'tmdb': parseInt(movie.tmdb_id,10),
						'genres': movie.genres,
						'updated': new Date()
					};
					movieCollection.update({'imdb':record.imdb},{$set:record},{'upsert':true}, function(error,affected,status){
						if (error) return logger.error(error);
						if (affected){
							self.addUser(user, record.imdb);
							self.getArtwork(record.imdb);
						}
					});
				});
				if (typeof(callback) == 'function') callback(error, {'library':true,'count':movies.length});
			});
			
			trakt(user.trakt).user.watchlist.movies(function(error, movies){
				logger.debug('Syncing watchlist...');
				if (error) logger.error(error);
				if (movies){
					logger.debug('Movie Watchlist: ', movies.length);
					movies.forEach(function(movie){
						var record = {
							'title': movie.title,
							'year': parseInt(movie.year,10),
							'url': movie.url.split('/').pop(),
							'synopsis': movie.overview,
							'released': new Date(movie.released*1000),
							'runtime': movie.runtime,
							'imdb': movie.imdb_id,
							'tmdb': parseInt(movie.tmdb_id,10),
							'genres': movie.genres,
							'watchlist': true,
							'updated': new Date()
						};
						movieCollection.update({'imdb':record.imdb},{$set:record},{'upsert':true}, function(error,affected){
							self.getArtwork(record.imdb);
						});
					});
				}
				if (typeof(callback) == 'function') callback(error, {'watchlist':true,'count':movies.length});
			});
		} catch(e){
			logger.error('Movie sync: ', e.message);
		}
	},
	
	unlink: function(imdb,callback){
		var deferred = Q.defer(), self = this
		movieCollection.findOne({'imdb':imdb},function(error, movie){
			if (error){
				logger.error(error);
				deferred.reject(error);
			}	
			if (movie){
				var basedir = nconf.get('media:base')+nconf.get('media:movies:directory');
				if (movie.file && movie.genres){
					var filename = path.basename(movie.file);
					movie.genres.forEach(function(genre){
						fs.unlink(basedir+'/Genres/'+genre+'/'+filename, function(error){
							if (error) return logger.error(error);
							logger.debug('Removed: %s/%s', genre, filename)
						});
					});
			//		fs.unlink(basedir+'/A-Z/'+movie.file, function(error){
			//			if (error) return logger.error(error);
			//			logger.debug('Removed: A-Z/%s', movie.file);
			//		});
				}
			}
			if (typeof(callback) == 'function') callback(error);
		});
		return deferred.promise;
	},
	
	
	watched: function(user,imdb){
		
		
		
	},
	
	/*****  *****/
	
	addUser: function(user,imdb){
		// Add user to movie
		var deferred = Q.defer(), self = this;
		var addUser = function(record){
			movieCollection.update({'imdb':imdb},record,function(error,affected){
				if (error) logger.error(error);
			});
		};
		movieCollection.findOne({'imdb':imdb},function(error,movie){
			if (error) logger.error(error);
			if (movie){
				var record = {
					'_id': ObjectID(user._id),
					'username': user.username
				};
				if (movie.users){
					var users = movie.users.filter(function(u){
						if (ObjectID(user._id).equals(u._id)) return true;
						return false;
					});
					if (!users.length) {
						addUser({$addToSet:record});
					}
				} else {
					addUser({$set:{'users':[record]}})
				}
				
			}
			if (error) deferred.reject(error);
		});
		return deferred.promise;
	},
	clearSymlinks: function(callback){
		var self = this;
		var directory = nconf.get('media:base')+nconf.get('media:movies:directory')+'/Genres';
		
		helper.listDirectory(directory, function(error, file){
			if (error) logger.error(error);
			if (file.stat){
				if (file.stat.isSymbolicLink()){
					logger.debug('Unlink: ', file.path);
					fs.unlink(file.path);
				}
			}
		});
		if (typeof(callback) == 'function') callback();
	},
	countUnmatched: function(){
		var deferred = Q.defer();
		unmatchedCollection.count({'type':'movie'}, function(error,count){
			if (error) logger.error(error);
			deferred.resolve(count);
			if (typeof(callback) == 'function') callback(count);
		});
		return deferred.promise;
	},
	rebuildGenres: function(callback){
		var self = this;
		movieCollection.find({'file':{$exists:true},'genres':{$exists:true}},{'imdb':1}).toArray(function(error,movies){
			if (error) logger.error(error);
			if (movies){
				// Delete all existing symlinks
				self.clearSymlinks(function(){
					setTimeout(function(){
						if (movies.length){
							movies.forEach(function(movie){
								self.link(movie.imdb);
							});
						}
						if (typeof(callback) == 'function') callback();
					}, 10000);
				});
			}
		});
	},
	
	getAlpha: function(name){
		var title = name.replace(/^The\s/, '').trim(), alpha = title.substr(0,1).toUpperCase();
		if (alpha.match(/\d/)) alpha = '#';
		return alpha; 
	},
	getArtwork: function(imdb, callback){
		var deferred = Q.defer(), self = this;
		movieCollection.findOne({'imdb':imdb},function(error, movie){
			if (error) logger.error(error);
			if (movie){
				userCollection.findOne({'admin':true,'trakt':{$exists:true}},{'trakt':1}, function(error,admin){
					if (error) logger.error(error);
					if (admin){
						trakt.movie(movie.imdb).summary().then(function(json){
							if (json.images.poster) {
								var poster = fs.createWriteStream(nconf.get('media:base') + nconf.get('media:movies:directory') + '/.artwork/' + movie.imdb + '.jpg', {'flags':'w','mode':644});
								poster.on('error', function(e){
									logger.error(e);
								});
								request(json.images.poster.thumb).pipe(poster);
								deferred.resolve(movie);
							}
							if (typeof(callback) == 'function') callback(null, movie.imdb);
						});
					} else {
						deferred.reject();
					}
				});
			}
		});
		return deferred.promise;
	},
	getFilename: function(movie, file){
		var self = this;
		var alpha = self.getAlpha(movie.title), blocks = [], ext = path.extname(file), quality = self.getQuality(file), record = {status: true};
		blocks.push(movie.title.replace(/[\\\/\[\]]/ig, ''));
		blocks.push('('+movie.year+')');
		if (movie.downloading || movie.quality || quality) {
			record.quality = movie.downloading || movie.quality || quality;
			blocks.push('['+record.quality+']')
		}
		record.file = alpha+'/'+blocks.join(' ')+ext;
		return record;
	},
	getHashes: function(imdb, callback){
		var self = this;
		movieCollection.findOne({'imdb':imdb}, function(error, movie){
			if (error) {
				if (typeof(callback) == 'function') callback(error);
				return logger.error(error);
			}
			if (movie){
				var req = {
					'url': 'https://yts.wf/api/listimdb.json',
					'method': 'GET',
					'json': true,
					'qs': {'imdb_id': movie.imdb}
				};
				if (nconf.get('system:proxy')) {
					req.tunnel = true;
					req.proxy = nconf.get('system:proxy');
				}
				request(req, function(error, res, json){
					if (error) {
						logger.error(error)
						if (typeof(callback) == 'function') return callback(error, null);
						return;
					}
					if (json){
						var torrents = [];
						try {
							if (typeof(json) != 'object') json = JSON.parse(json);
							if (json.status == 'fail'){
								if (typeof(callback) == 'function') callback(json.error, torrents);
							} else if (json.MovieCount){
								json.MovieList.forEach(function(result){
									var object = {
										'hash': result.TorrentHash.toUpperCase(),
										'quality': result.Quality,
										'size': parseInt(result.SizeByte,10)
									};
									torrents.push(object);
								});
								if (torrents.length) {
									var update = {
										hashes: torrents,
										updated: new Date()
									};
									movieCollection.update({'_id':ObjectID(movie._id)},{$set:update},{'w':0});
								}
							}
							if (typeof(callback) == 'function') callback(json.error, torrents);
						} catch(e){
							logger.error('YTS: ', e.message);
						}
					}
				})
			}
		});
	},
	getLatest: function(){
		try {
			var req = {
				'url': 'https://yts.wf/api/list.json',
				'method': 'GET',
				'json': true,
				'qs': {'limit': 25}
			};
			if (nconf.get('system:proxy')) {
				req.tunnel = true;
				req.proxy = nconf.get('system:proxy');
			}
			request(req, function(error,res,json){
				if (error) return logger.error(error);
				try {
					if (typeof(json) != 'object') json = JSON.parse(json);
					if (json.MovieCount){
						json.MovieList.forEach(function(result){
							var object = {
								'hash': result.TorrentHash.toUpperCase(),
								'quality': result.Quality,
								'size': parseInt(result.SizeByte,10)
							};
							movieCollection.update({'imdb':result.ImdbCode},{$set:{'updated': new Date()},$addToSet:{'hashes':object}},{'w':0});
						});
					}
				} catch(e){
					logger.error(e.message);
				}
			});
		} catch(e){
			logger.error(e.message);
		}
	},
	getQuality: function(file){
		var quality = '480p';
		if (file.match(/(1080p|720p|480p)/i)) quality = file.match(/(1080p|720p|480p)/i)[1];
		return quality;
	},
	getUnhashed: function(){
		var self = this;
		movieCollection.find({'hashes':{$exists:false}},{'imdb':1}).toArray(function(error, movies){
			if (error) logger.error('getUnhashed:', error);
			if (movies){
				movies.forEach(function(movie){
					self.getHashes(movie.imdb);
				});
			}
		})
	},
	getUnmatched: function(callback){
		unmatchedCollection.find({type: 'movie'}).sort({title:1}).limit(20).toArray(callback);
	},
	
	cleanHashes: function(){
		var self = this;
		movieCollection.find({'hashes':{$exists:true}},{'imdb':1}).toArray(function(error,movies){
			if (error) logger.error(error);
			if (movies){
				logger.debug('Updating movie hashes')
				movies.forEach(function(movie){
					self.getHashes(movie.imdb)
				});
			}
		})
	}
};
exports = module.exports = MovieData;